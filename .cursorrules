This is a context for AI editor/agent about the project. It's generated with a tool Airul (https://github.com/mitkury/airul) out of 20 sources. Feel free to edit .airul.json to change the sources and configure editors. Run `airul gen` to update the context after making changes to .airul.json or the sources. Remember to update TODO-AI.md after major changes in the project, keeping track of completed tasks and new developments.

# From README.md:

# Markpage

A standalone npm package for building and rendering markdown-based content with distributed navigation structure for any framework.

## Project Structure

This is a monorepo with the following packages:

- **`packages/markpage`** - The main package that gets published to npm
- **`packages/tests`** - Comprehensive test suite for the package
- **`packages/examples`** - Example SvelteKit project demonstrating usage

## Features

- **Distributed Navigation**: Each folder defines its own structure with `.index.json` files
- **Multiple Output Formats**: App bundles, website navigation, and static HTML sites
- **Type-Safe**: Full TypeScript support with Zod validation
- **Framework Agnostic**: Works with any framework or no framework at all
- **Flexible**: Point to any directory with markdown and `.index.json` files
- **Comprehensive Testing**: >90% test coverage with comprehensive test suite

## Development

### Prerequisites

- Node.js 18+
- npm

### Setup

```bash
# Install dependencies for all packages
npm install

# Build the main package
npm run build

# Run tests
npm test

# Build examples
npm run build:examples

# Start examples in development mode
npm run dev:examples
```

### Package Scripts

- `npm run build` - Build the main markpage package
- `npm run dev` - Watch mode for the main package
- `npm test` - Run all tests
- `npm run test:watch` - Run tests in watch mode
- `npm run test:coverage` - Run tests with coverage report
- `npm run build:examples` - Build the example SvelteKit project
- `npm run dev:examples` - Start the example project in development mode

## Installation

```bash
npm install markpage
```

## Quick Start

### 1. Create Content Structure

Create a directory with your markdown content and `.index.json` files:

```
my-content/
├── .index.json
├── getting-started.md
└── guides/
    ├── .index.json
    └── installation.md
```

### 2. Define Navigation

**Root level** (`my-content/.index.json`):
```json
{
  "items": [
    { "name": "getting-started", "type": "page", "label": "Getting Started" },
    { "name": "guides", "type": "section", "label": "Guides" }
  ]
}
```

**Section level** (`my-content/guides/.index.json`):
```json
{
  "items": [
    { "name": "installation", "type": "page", "label": "Installation" }
  ]
}
```

### 3. Build Documentation

```typescript
import { buildPages } from 'markpage/builder';

await buildPages('./my-content', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true
});
```

### 4. Use in Your App

```typescript
import { NavigationTree, loadContent } from 'markpage/renderer';
import navigationData from './src/lib/content/navigation.json';
import contentBundle from './src/lib/content/content.json';

const navigation = new NavigationTree(navigationData);
const content = await loadContent('getting-started.md', contentBundle);
```

## CLI Usage

### Build for App/Website

```bash
npx markpage build ./my-content --output ./src/lib/content
```

### Generate Static Site

```bash
npx markpage static ./my-content --output ./dist
```

## API Reference

### Builder Module

#### `buildPages(contentPath, options?)`

Builds documentation from a content directory.

```typescript
import { buildPages } from 'markpage/builder';

const result = await buildPages('./content', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true
});
```

#### `generateStaticSite(contentPath, outputPath, options?)`

Generates a complete static HTML site.

```typescript
import { generateStaticSite } from 'markpage/builder';

const result = await generateStaticSite('./content', './dist', {
  title: 'My Documentation',
  baseUrl: 'https://example.com',
  includeIndex: true
});
```

### Renderer Module

#### `NavigationTree`

Manages navigation structure and provides navigation utilities.

```typescript
import { NavigationTree } from 'markpage/renderer';

const navigation = new NavigationTree(navigationData);

// Find items
const item = navigation.findItemByPath('guides/installation.md');

// Get breadcrumbs
const breadcrumbs = navigation.getBreadcrumbs('guides/installation.md');

// Get siblings
const siblings = navigation.getSiblings('guides/installation.md');
const nextSibling = navigation.getNextSibling('guides/installation.md');
const prevSibling = navigation.getPreviousSibling('guides/installation.md');
```

#### `ContentLoader`

Manages content loading and processing.

```typescript
import { ContentLoader } from 'markpage/renderer';

const loader = new ContentLoader(contentBundle);

// Load content
const content = loader.loadAndProcess('getting-started.md');

// Check availability
const hasContent = loader.hasContent('guides/installation.md');
const paths = loader.getAvailablePaths();
```

#### `loadContent(path, contentBundle, processor?)`

Loads and processes content for a specific path.

```typescript
import { loadContent } from 'markpage/renderer';

const content = await loadContent('getting-started.md', contentBundle);
```

### Content Processing

#### Custom Processors

You can provide custom content processors for advanced transformations:

```typescript
const processor = {
  process(content: string): string {
    // Add table of contents
    return addTableOfContents(content);
  }
};

const content = await loadContent('page.md', contentBundle, processor);
```

#### Utility Functions

```typescript
import { 
  extractHeadings, 
  extractTableOfContents, 
  addTableOfContents 
} from 'markpage/renderer';

// Extract headings from markdown
const headings = extractHeadings(content);

// Generate table of contents
const toc = extractTableOfContents(content);

// Add table of contents to content
const contentWithToc = addTableOfContents(content);
```

## Content Structure

### Index.json Format

Each directory can contain a `.index.json` file that defines the navigation structure:

```json
{
  "items": [
    { "name": "page-name", "type": "page", "label": "Page Label" },
    { "name": "section-name", "type": "section", "label": "Section Label" }
  ]
}
```

### Item Properties

- `name`: File/directory name (without extension)
- `type`: Either `"page"` or `"section"`
- `label`: Display label for navigation
- `collapsed`: Optional boolean to collapse sections by default
- `url`: Optional external URL

### File Structure

- Pages: `{name}.md` files
- Sections: `{name}/` directories with their own `.index.json`

## Use Cases

### Documentation Sites

```bash
npx markpage build ./docs --output ./src/lib/docs
```

### Blog Systems

```bash
npx markpage build ./blog --output ./src/lib/blog
```

### Knowledge Bases

```bash
npx markpage build ./kb --output ./src/lib/kb
```

### Static Sites

```bash
npx markpage static ./content --output ./dist
```

## Integration Examples

### SvelteKit Integration

```svelte
<!-- src/routes/docs/[...slug]/+page.svelte -->
<script lang="ts">
  import { NavigationTree } from 'markpage/renderer';
  import { DocsSidebar, DocsContent } from 'markpage/components';
  import navigationData from '$lib/content/navigation.json';
  
  export let data;
  let { content, slug } = data;
  
  let navigation = $state(new NavigationTree(navigationData));
</script>

<div class="docs-layout">
  <DocsSidebar {navigation} currentPage={slug} />
  <DocsContent {content} />
</div>
```

### App Integration

```svelte
<!-- src/lib/components/ContentPopover.svelte -->
<script lang="ts">
  import { NavigationTree, loadContent } from 'markpage/renderer';
  import { DocsSidebar, DocsContent } from 'markpage/components';
  import navigationData from '$lib/content/navigation.json';
  import contentBundle from '$lib/content/content.json';
  
  let navigation = $state(new NavigationTree(navigationData));
  let currentPage = $state<string | null>(null);
  let pageContent = $state<string | null>(null);
  
  $effect(() => {
    if (currentPage) {
      loadContent(currentPage, contentBundle).then(content => {
        pageContent = content;
      });
    }
  });
</script>

<div class="content-popover">
  <DocsSidebar {navigation} bind:currentPage />
  <DocsContent {pageContent} />
</div>
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## License

MIT License - see LICENSE file for details.
---

# From docs/.index.json:

{
  "items": [
    { "name": "getting-started", "type": "page", "label": "Getting Started" },
    { "name": "guides", "type": "section", "label": "Guides" },
    { "name": "api", "type": "section", "label": "API Reference" }
  ]
}
---

# From docs/api/.index.json:

{
  "items": [
    { "name": "builder", "type": "page", "label": "Builder" },
    { "name": "renderer", "type": "page", "label": "Renderer" },
    { "name": "types", "type": "page", "label": "Types" }
  ]
}
---

# From docs/api/builder.md:

# Builder API

The builder module provides functions for building documentation from markdown content and generating various output formats.

## Functions

### `buildPages(contentPath, options?)`

Builds documentation from a content directory.

**Parameters:**
- `contentPath` (string): Path to the content directory
- `options` (BuildOptions, optional): Build configuration options

**Returns:** Promise<BuildResult>

**Example:**
```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

const result = await buildPages('./docs', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true
});
```

### `generateStaticSite(contentPath, outputPath, options?)`

Generates a complete static HTML site from markdown content.

**Parameters:**
- `contentPath` (string): Path to the content directory
- `outputPath` (string): Path where the static site will be generated
- `options` (StaticSiteOptions, optional): Static site configuration options

**Returns:** Promise<StaticSiteResult>

**Example:**
```typescript
import { generateStaticSite } from 'svelte-markdown-pages/builder';

const result = await generateStaticSite('./docs', './dist', {
  title: 'My Documentation',
  baseUrl: 'https://example.com',
  includeIndex: true
});
```

## Types

### BuildOptions

Configuration options for the `buildPages` function.

```typescript
interface BuildOptions {
  appOutput?: string;
  websiteOutput?: string;
  staticOutput?: string;
  includeContent?: boolean;
}
```

**Properties:**
- `appOutput` (string, optional): Directory for app-specific output files
- `websiteOutput` (string, optional): Directory for website-specific output files
- `staticOutput` (string, optional): Directory for static site output
- `includeContent` (boolean, optional): Whether to include content in output bundles (default: false)

### StaticSiteOptions

Configuration options for the `generateStaticSite` function.

```typescript
interface StaticSiteOptions {
  title?: string;
  baseUrl?: string;
  css?: string;
  js?: string;
  processor?: ContentProcessor;
  includeIndex?: boolean;
  indexTitle?: string;
}
```

**Properties:**
- `title` (string, optional): Site title for generated HTML
- `baseUrl` (string, optional): Base URL for the site
- `css` (string, optional): Custom CSS content to include
- `js` (string, optional): Custom JavaScript content to include
- `processor` (ContentProcessor, optional): Custom content processor
- `includeIndex` (boolean, optional): Whether to generate an index page (default: false)
- `indexTitle` (string, optional): Title for the generated index page

### BuildResult

Result object returned by `buildPages`.

```typescript
interface BuildResult {
  navigation: NavigationTree;
  content?: Record<string, string>;
  pages?: Array<{
    path: string;
    content: string;
    html: string;
  }>;
}
```

**Properties:**
- `navigation` (NavigationTree): Generated navigation structure
- `content` (Record<string, string>, optional): Content bundle (if includeContent is true)
- `pages` (Array, optional): Array of generated pages with path, content, and HTML

### StaticSiteResult

Result object returned by `generateStaticSite`.

```typescript
interface StaticSiteResult {
  files: string[];
  stats: BuildStats;
  urls: string[];
}
```

**Properties:**
- `files` (string[]): List of generated files
- `stats` (BuildStats): Build statistics
- `urls` (string[]): List of generated URLs

### ContentProcessor

Interface for custom content processors.

```typescript
interface ContentProcessor {
  process(content: string): string;
}
```

**Methods:**
- `process(content: string): string`: Process and transform content

### Plugin

Interface for plugins.

```typescript
interface Plugin {
  name: string;
  version: string;
  process?: (content: string) => string;
  transform?: (content: string) => string;
  validate?: (content: string) => boolean;
  beforeBuild?: () => void;
  afterBuild?: (result: any) => void;
}
```

**Properties:**
- `name` (string): Plugin name
- `version` (string): Plugin version
- `process` (function, optional): Content processing function
- `transform` (function, optional): Content transformation function
- `validate` (function, optional): Content validation function
- `beforeBuild` (function, optional): Pre-build hook
- `afterBuild` (function, optional): Post-build hook

### BuildHooks

Lifecycle hooks for the build process.

```typescript
interface BuildHooks {
  beforeBuild?: (contentPath: string) => void | Promise<void>;
  afterBuild?: (result: BuildResult) => void | Promise<void>;
  onError?: (error: Error) => void;
}
```

**Properties:**
- `beforeBuild` (function, optional): Called before build starts
- `afterBuild` (function, optional): Called after build completes
- `onError` (function, optional): Called when build errors occur



## Examples

### Basic Build

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

const result = await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true
});

console.log(`Built navigation with ${result.navigation.items.length} root items`);
```

### Advanced Build with Custom Processor

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

const customProcessor = {
  process(content: string): string {
    return content.replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>');
  }
};

const result = await buildPages('./docs', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true,
  processor: customProcessor
});
```

### Static Site Generation

```typescript
import { generateStaticSite } from 'svelte-markdown-pages/builder';

const result = await generateStaticSite('./docs', './dist', {
  title: 'My Documentation',
  baseUrl: 'https://docs.example.com',
  css: `
    body { font-family: 'Inter', sans-serif; }
    .docs-content { max-width: 800px; margin: 0 auto; }
  `,
  js: `
    // Add syntax highlighting
    hljs.highlightAll();
  `,
  includeIndex: true,
  indexTitle: 'Documentation Home'
});

console.log(`Generated ${result.pages?.length || 0} pages`);
console.log(`Available URLs: ${result.urls.join(', ')}`);
```

### Error Handling

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

try {
  const result = await buildPages('./docs', {
    appOutput: './src/lib/content',
    includeContent: true
  });
  
  if (result.stats.errors.length > 0) {
    console.error('Build completed with errors:', result.stats.errors);
  }
  
  if (result.stats.warnings.length > 0) {
    console.warn('Build completed with warnings:', result.stats.warnings);
  }
} catch (error) {
  console.error('Build failed:', error.message);
  process.exit(1);
}
```

## Error Codes

The builder functions may throw errors with specific error codes:

- `ENOENT`: Content directory not found
- `INVALID_INDEX`: Invalid `.index.json` file
- `MISSING_CONTENT`: Required content file missing
- `PROCESSING_ERROR`: Content processing failed
- `PLUGIN_ERROR`: Plugin execution failed

## Performance Considerations

### Large Documentation Sites

For large documentation sites, consider:

1. **Disable content inclusion** if not needed:
   ```typescript
   await buildPages('./docs', {
     appOutput: './src/lib/content',
     includeContent: false
   });
   ```

2. **Use efficient processors**:
   ```typescript
   const efficientProcessor = {
     process(content: string): string {
       // Use efficient string operations
       return content.replace(/pattern/g, 'replacement');
     }
   };
   ```

3. **Implement caching**:
   ```typescript
   const cache = new Map();
   
   const cachedProcessor = {
     process(content: string): string {
       const hash = createHash(content);
       if (cache.has(hash)) {
         return cache.get(hash);
       }
       
       const result = processContent(content);
       cache.set(hash, result);
       return result;
     }
   };
   ```

## Related

- [Renderer API](./renderer.md) - Content rendering and navigation
- [Types](./types.md) - Type definitions and interfaces
---

# From docs/api/renderer.md:

# Renderer API

The renderer module provides classes and functions for rendering content and managing navigation in your Svelte applications.

## Classes

### `NavigationTree`

Manages navigation structure and provides navigation utilities.

```typescript
import { NavigationTree } from 'svelte-markdown-pages/renderer';

const navigation = new NavigationTree(navigationData);
```

#### Constructor

**Parameters:**
- `navigationData` (NavigationData): Navigation structure data

#### Methods

##### `findItemByPath(path: string): NavigationItem | undefined`

Finds a navigation item by its file path.

**Parameters:**
- `path` (string): File path to search for

**Returns:** NavigationItem | undefined

**Example:**
```typescript
const item = navigation.findItemByPath('guides/installation.md');
if (item) {
  console.log('Found item:', item.label);
}
```

##### `getBreadcrumbs(path: string): NavigationItem[]`

Gets the breadcrumb trail for a given path.

**Parameters:**
- `path` (string): File path to get breadcrumbs for

**Returns:** NavigationItem[]

**Example:**
```typescript
const breadcrumbs = navigation.getBreadcrumbs('guides/advanced/customization.md');
// Returns: [root, guides, advanced, customization]
```

##### `getSiblings(path: string): NavigationItem[]`

Gets sibling items for a given path.

**Parameters:**
- `path` (string): File path to get siblings for

**Returns:** NavigationItem[]

**Example:**
```typescript
const siblings = navigation.getSiblings('guides/installation.md');
// Returns: [installation, configuration, advanced]
```

##### `getNextSibling(path: string): NavigationItem | undefined`

Gets the next sibling item.

**Parameters:**
- `path` (string): Current file path

**Returns:** NavigationItem | undefined

**Example:**
```typescript
const next = navigation.getNextSibling('guides/installation.md');
if (next) {
  console.log('Next page:', next.label);
}
```

##### `getPreviousSibling(path: string): NavigationItem | undefined`

Gets the previous sibling item.

**Parameters:**
- `path` (string): Current file path

**Returns:** NavigationItem | undefined

**Example:**
```typescript
const prev = navigation.getPreviousSibling('guides/configuration.md');
if (prev) {
  console.log('Previous page:', prev.label);
}
```

##### `getChildren(path: string): NavigationItem[]`

Gets child items for a given path.

**Parameters:**
- `path` (string): Parent path to get children for

**Returns:** NavigationItem[]

**Example:**
```typescript
const children = navigation.getChildren('guides');
// Returns: [installation, configuration, advanced]
```

##### `findItemByName(name: string): NavigationItem | undefined`

Finds a navigation item by its name.

**Parameters:**
- `path` (string): Item name to search for

**Returns:** NavigationItem | undefined

**Example:**
```typescript
const item = navigation.findItemByName('installation');
if (item) {
  console.log('Found item:', item.label);
}
```

##### `isExpanded(path: string): boolean`

Checks if a section is expanded.

**Parameters:**
- `path` (string): Path to check

**Returns:** boolean

**Example:**
```typescript
const expanded = navigation.isExpanded('guides');
console.log('Guides section expanded:', expanded);
```

##### `toggleExpanded(path: string): void`

Toggles the expanded state of a section.

**Parameters:**
- `path` (string): Path to toggle

**Example:**
```typescript
navigation.toggleExpanded('guides');
```

##### `getChildren(path: string): NavigationItem[]`

Gets child items for a given path.

**Parameters:**
- `path` (string): Parent path to get children for

**Returns:** NavigationItem[]

**Example:**
```typescript
const children = navigation.getChildren('guides');
// Returns: [installation, configuration, advanced]
```

##### `getParent(path: string): NavigationItem | null`

Gets the parent item for a given path.

**Parameters:**
- `path` (string): Child path to get parent for

**Returns:** NavigationItem | null

**Example:**
```typescript
const parent = navigation.getParent('guides/installation.md');
if (parent) {
  console.log('Parent section:', parent.label);
}
```

### `ContentLoader`

Manages content loading and processing.

```typescript
import { ContentLoader } from 'svelte-markdown-pages/renderer';

const loader = new ContentLoader(contentBundle);
```

#### Constructor

**Parameters:**
- `contentBundle` (ContentBundle): Content bundle data

#### Methods

##### `loadAndProcess(path: string, processor?: ContentProcessor): string`

Loads and processes content for a specific path.

**Parameters:**
- `path` (string): Content path to load
- `processor` (ContentProcessor, optional): Custom content processor

**Returns:** string

**Example:**
```typescript
const content = loader.loadAndProcess('getting-started.md');
console.log('Content loaded:', content.length, 'characters');
```

##### `hasContent(path: string): boolean`

Checks if content exists for a given path.

**Parameters:**
- `path` (string): Content path to check

**Returns:** boolean

**Example:**
```typescript
if (loader.hasContent('guides/installation.md')) {
  console.log('Installation guide exists');
}
```

##### `getAvailablePaths(): string[]`

Gets all available content paths.

**Returns:** string[]

**Example:**
```typescript
const paths = loader.getAvailablePaths();
console.log('Available content:', paths);
```

##### `getContentMetadata(path: string): ContentMetadata | null`

Gets metadata for a content file.

**Parameters:**
- `path` (string): Content path to get metadata for

**Returns:** ContentMetadata | null

**Example:**
```typescript
const metadata = loader.getContentMetadata('getting-started.md');
if (metadata) {
  console.log('Title:', metadata.title);
  console.log('Last modified:', metadata.lastModified);
}
```

## Functions

### `loadContent(path, contentBundle, processor?)`

Loads and processes content for a specific path.

**Parameters:**
- `path` (string): Content path to load
- `contentBundle` (ContentBundle): Content bundle data
- `processor` (ContentProcessor, optional): Custom content processor

**Returns:** Promise<string | undefined>

**Example:**
```typescript
import { loadContent } from 'svelte-markdown-pages/renderer';

const content = await loadContent('getting-started.md', contentBundle);
```

### `extractHeadings(content: string): Heading[]`

Extracts headings from markdown content.

**Parameters:**
- `content` (string): Markdown content to extract headings from

**Returns:** Heading[]

**Example:**
```typescript
import { extractHeadings } from 'svelte-markdown-pages/renderer';

const headings = extractHeadings(content);
headings.forEach(heading => {
  console.log(`${'#'.repeat(heading.level)} ${heading.text}`);
});
```

### `extractTableOfContents(content: string): TableOfContentsItem[]`

Extracts table of contents from markdown content.

**Parameters:**
- `content` (string): Markdown content to extract TOC from

**Returns:** TableOfContentsItem[]

**Example:**
```typescript
import { extractTableOfContents } from 'svelte-markdown-pages/renderer';

const toc = extractTableOfContents(content);
toc.forEach(item => {
  console.log(`${'  '.repeat(item.depth)}- ${item.text}`);
});
```

### `addTableOfContents(content: string, toc?: TableOfContentsItem[]): string`

Adds a table of contents to markdown content.

**Parameters:**
- `content` (string): Markdown content to add TOC to
- `toc` (TableOfContentsItem[], optional): Pre-generated TOC

**Returns:** string

**Example:**
```typescript
import { addTableOfContents } from 'svelte-markdown-pages/renderer';

const contentWithToc = addTableOfContents(content);
```

## Types

### NavigationItem

Represents a navigation item.

```typescript
interface NavigationItem {
  name: string;
  type: 'page' | 'section';
  label: string;
  items?: NavigationItem[];
  collapsed?: boolean;
  url?: string;
}
```

**Properties:**
- `name` (string): File/directory name (without extension)
- `type` ('page' | 'section'): Item type
- `label` (string): Display label
- `items` (NavigationItem[], optional): Child items (for sections)
- `collapsed` (boolean, optional): Whether section is collapsed by default
- `url` (string, optional): External URL

### NavigationData

Complete navigation structure.

```typescript
interface NavigationData {
  items: NavigationItem[];
}
```

### ContentBundle

Bundle containing all content data.

```typescript
interface ContentBundle {
  [path: string]: string;
}
```

### ContentMetadata

Metadata for a content file.

```typescript
interface ContentMetadata {
  title: string;
  description?: string;
  lastModified: Date;
  wordCount: number;
  readingTime: number;
}
```

### Heading

Represents a markdown heading.

```typescript
interface Heading {
  level: number;
  text: string;
  id: string;
  line: number;
}
```

**Properties:**
- `level` (number): Heading level (1-6)
- `text` (string): Heading text
- `id` (string): Generated heading ID
- `line` (number): Line number in source

### TableOfContentsItem

Represents a table of contents item.

```typescript
interface TableOfContentsItem {
  level: number;
  text: string;
  id: string;
  children: TableOfContentsItem[];
}
```

**Properties:**
- `level` (number): Heading level
- `text` (string): Heading text
- `id` (string): Heading ID
- `children` (TableOfContentsItem[]): Child items

### ContentProcessor

Interface for content processors.

```typescript
interface ContentProcessor {
  process(content: string): string;
}
```

## Examples

### Basic Navigation Usage

```typescript
import { NavigationTree } from 'svelte-markdown-pages/renderer';
import navigationData from './content/navigation.json';

const navigation = new NavigationTree(navigationData);

// Find current page
const currentPage = navigation.findItemByPath('guides/installation.md');

// Get breadcrumbs
const breadcrumbs = navigation.getBreadcrumbs('guides/installation.md');

// Get navigation siblings
const nextPage = navigation.getNextSibling('guides/installation.md');
const prevPage = navigation.getPreviousSibling('guides/installation.md');
```

### Content Loading

```typescript
import { ContentLoader, loadContent } from 'svelte-markdown-pages/renderer';
import contentBundle from './content/content.json';

// Using ContentLoader class
const loader = new ContentLoader(contentBundle);
const content = loader.loadAndProcess('getting-started.md');

// Using loadContent function
const content = await loadContent('getting-started.md', contentBundle);
```

### Table of Contents

```typescript
import { 
  extractHeadings, 
  extractTableOfContents, 
  addTableOfContents 
} from 'svelte-markdown-pages/renderer';

// Extract headings
const headings = extractHeadings(content);

// Generate table of contents
const toc = extractTableOfContents(content);

// Add table of contents to content
const contentWithToc = addTableOfContents(content, toc);
```

### Custom Content Processing

```typescript
import { loadContent } from 'svelte-markdown-pages/renderer';

const customProcessor = {
  process(content: string): string {
    // Add custom processing
    return content
      .replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>')
      .replace(/\[\[(.+?)\]\]/g, '<InternalLink>$1</InternalLink>');
  }
};

const processedContent = await loadContent(
  'getting-started.md', 
  contentBundle, 
  customProcessor
);
```

### Svelte Component Integration

```svelte
<script lang="ts">
  import { NavigationTree, loadContent } from 'svelte-markdown-pages/renderer';
  import type { NavigationItem } from 'svelte-markdown-pages';
  import navigationData from '$lib/content/navigation.json';
  import contentBundle from '$lib/content/content.json';
  
  let navigation = $state(new NavigationTree(navigationData));
  let currentPage = $state<string>("getting-started.md");
  let pageContent = $state<string | null>(null);
  
  $effect(() => {
    if (currentPage && contentBundle) {
      loadContent(currentPage, contentBundle).then(content => {
        pageContent = content;
      });
    }
  });
  
  function handlePageSelect(path: string) {
    currentPage = path;
  }
  
  function renderNavigationItems(items: NavigationItem[]): string {
    return items.map(item => {
      if (item.type === 'section') {
        return `
          <div class="nav-section">
            <h3>${item.label}</h3>
            ${renderNavigationItems(item.items || [])}
          </div>
        `;
      } else {
        const isActive = currentPage === item.name + '.md';
        return `
          <button 
            class="nav-link ${isActive ? 'active' : ''}"
            onclick="window.dispatchEvent(new CustomEvent('pageSelect', { detail: '${item.name}.md' }))"
          >
            ${item.label}
          </button>
        `;
      }
    }).join('');
  }
  
  // Set up event listener
  if (typeof window !== 'undefined') {
    window.addEventListener('pageSelect', (event: any) => {
      handlePageSelect(event.detail);
    });
  }
</script>

<div class="docs-layout">
  <nav class="docs-sidebar">
    {@html renderNavigationItems(navigation.items)}
  </nav>
  
  <div class="docs-content">
    {@html pageContent || 'No content selected'}
  </div>
</div>
```

## Error Handling

### Content Loading Errors

```typescript
import { loadContent } from 'svelte-markdown-pages/renderer';

try {
  const content = await loadContent('non-existent.md', contentBundle);
} catch (error) {
  if (error.code === 'CONTENT_NOT_FOUND') {
    console.error('Content not found');
  } else {
    console.error('Failed to load content:', error.message);
  }
}
```

### Navigation Errors

```typescript
import { NavigationTree } from 'svelte-markdown-pages/renderer';

try {
  const navigation = new NavigationTree(navigationData);
  const item = navigation.findItemByPath('invalid/path.md');
  
  if (!item) {
    console.warn('Navigation item not found');
  }
} catch (error) {
  console.error('Navigation error:', error.message);
}
```

## Performance Considerations

### Lazy Loading

For large content bundles, consider lazy loading:

```typescript
const lazyLoader = {
  async loadContent(path: string): Promise<string> {
    // Load content on demand
    const response = await fetch(`/api/content/${path}`);
    return response.text();
  }
};
```

### Caching

Implement caching for frequently accessed content:

```typescript
const contentCache = new Map();

async function loadContentWithCache(path: string, contentBundle: any): Promise<string> {
  if (contentCache.has(path)) {
    return contentCache.get(path);
  }
  
  const content = await loadContent(path, contentBundle);
  contentCache.set(path, content);
  return content;
}
```

## Related

- [Builder API](./builder.md) - Content building and generation
- [Types](./types.md) - Type definitions and interfaces
---

# From docs/api/types.md:

# Types

Complete type definitions and interfaces for svelte-markdown-pages.

## Core Types

### NavigationItem

Represents a navigation item in the documentation structure.

```typescript
interface NavigationItem {
  name: string;
  type: 'page' | 'section';
  label: string;
  items?: NavigationItem[];
  collapsed?: boolean;
  url?: string;
}
```

**Properties:**
- `name` (string): File/directory name without extension
- `type` ('page' | 'section'): Type of navigation item
- `label` (string): Display label for the item
- `items` (NavigationItem[], optional): Child items for sections
- `collapsed` (boolean, optional): Whether section is collapsed by default
- `url` (string, optional): External URL for the item

### NavigationData

Complete navigation structure for the documentation.

```typescript
interface NavigationData {
  items: NavigationItem[];
}
```

**Properties:**
- `items` (NavigationItem[]): Root-level navigation items

### ContentBundle

Bundle containing all content data indexed by file path.

```typescript
interface ContentBundle {
  [path: string]: string;
}
```

**Properties:**
- `[path: string]` (string): Content indexed by file path

## Builder Types

### BuildOptions

Configuration options for the `buildPages` function.

```typescript
interface BuildOptions {
  appOutput?: string;
  websiteOutput?: string;
  staticOutput?: string;
  includeContent?: boolean;
  processor?: ContentProcessor;
  plugins?: Plugin[];
  hooks?: BuildHooks;
}
```

**Properties:**
- `appOutput` (string, optional): Directory for app-specific output files
- `websiteOutput` (string, optional): Directory for website-specific output files
- `staticOutput` (string, optional): Directory for static site output
- `includeContent` (boolean, optional): Whether to include content in output bundles
- `processor` (ContentProcessor, optional): Custom content processor
- `plugins` (Plugin[], optional): Array of plugins to apply
- `hooks` (BuildHooks, optional): Build lifecycle hooks

### StaticSiteOptions

Configuration options for the `generateStaticSite` function.

```typescript
interface StaticSiteOptions {
  title?: string;
  baseUrl?: string;
  css?: string;
  js?: string;
  includeIndex?: boolean;
  indexTitle?: string;
  processor?: ContentProcessor;
  plugins?: Plugin[];
}
```

**Properties:**
- `title` (string, optional): Site title for generated HTML
- `baseUrl` (string, optional): Base URL for the site
- `css` (string, optional): Custom CSS content to include
- `js` (string, optional): Custom JavaScript content to include
- `includeIndex` (boolean, optional): Whether to generate an index page
- `indexTitle` (string, optional): Title for the generated index page
- `processor` (ContentProcessor, optional): Custom content processor
- `plugins` (Plugin[], optional): Array of plugins to apply

### BuildResult

Result object returned by `buildPages`.

```typescript
interface BuildResult {
  navigation: NavigationData;
  content?: ContentBundle;
  files: string[];
  stats: BuildStats;
}
```

**Properties:**
- `navigation` (NavigationData): Generated navigation structure
- `content` (ContentBundle, optional): Content bundle (if includeContent is true)
- `files` (string[]): List of generated files
- `stats` (BuildStats): Build statistics

### StaticSiteResult

Result object returned by `generateStaticSite`.

```typescript
interface StaticSiteResult {
  files: string[];
  stats: BuildStats;
  urls: string[];
}
```

**Properties:**
- `files` (string[]): List of generated files
- `stats` (BuildStats): Build statistics
- `urls` (string[]): List of generated URLs

### BuildStats

Statistics about the build process.

```typescript
interface BuildStats {
  pages: number;
  sections: number;
  totalFiles: number;
  buildTime: number;
  errors: string[];
  warnings: string[];
}
```

**Properties:**
- `pages` (number): Number of pages processed
- `sections` (number): Number of sections processed
- `totalFiles` (number): Total number of files processed
- `buildTime` (number): Build time in milliseconds
- `errors` (string[]): List of build errors
- `warnings` (string[]): List of build warnings



## Renderer Types

### ContentMetadata

Metadata for a content file.

```typescript
interface ContentMetadata {
  title: string;
  description?: string;
  lastModified: Date;
  wordCount: number;
  readingTime: number;
}
```

**Properties:**
- `title` (string): Content title
- `description` (string, optional): Content description
- `lastModified` (Date): Last modification date
- `wordCount` (number): Number of words in content
- `readingTime` (number): Estimated reading time in minutes

### Heading

Represents a markdown heading.

```typescript
interface Heading {
  level: number;
  text: string;
  id: string;
  line: number;
}
```

**Properties:**
- `level` (number): Heading level (1-6)
- `text` (string): Heading text
- `id` (string): Generated heading ID
- `line` (number): Line number in source

### TableOfContentsItem

Represents a table of contents item.

```typescript
interface TableOfContentsItem {
  level: number;
  text: string;
  id: string;
  children: TableOfContentsItem[];
}
```

**Properties:**
- `level` (number): Heading level
- `text` (string): Heading text
- `id` (string): Heading ID
- `children` (TableOfContentsItem[]): Child items

## Plugin Types



## Processor Types

### ContentProcessor

Interface for content processors.

```typescript
interface ContentProcessor {
  process(content: string): string;
}
```

**Methods:**
- `process(content: string): string`: Process and transform content

### ProcessorOptions

Options for content processors.

```typescript
interface ProcessorOptions {
  markdown?: boolean;
  html?: boolean;
  custom?: boolean;
}
```

**Properties:**
- `markdown` (boolean, optional): Whether to process markdown
- `html` (boolean, optional): Whether to process HTML
- `custom` (boolean, optional): Whether to apply custom processing

## Error Types

### BuildError

Error thrown during build process.

```typescript
interface BuildError extends Error {
  code: string;
  path?: string;
  details?: any;
}
```

**Properties:**
- `code` (string): Error code
- `path` (string, optional): File path where error occurred
- `details` (any, optional): Additional error details

### ContentError

Error thrown during content processing.

```typescript
interface ContentError extends Error {
  code: string;
  path: string;
  content?: string;
}
```

**Properties:**
- `code` (string): Error code
- `path` (string): Content file path
- `content` (string, optional): Content that caused error

## Utility Types

### DeepPartial

Makes all properties in T optional recursively.

```typescript
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
```

### RequiredKeys

Extracts keys of T that are required.

```typescript
type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
```

### OptionalKeys

Extracts keys of T that are optional.

```typescript
type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];
```

## Type Guards

### Type Guards for Runtime Validation

```typescript
function isNavigationItem(obj: any): obj is NavigationItem {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof obj.name === 'string' &&
    typeof obj.type === 'string' &&
    (obj.type === 'page' || obj.type === 'section') &&
    typeof obj.label === 'string'
  );
}

function isNavigationData(obj: any): obj is NavigationData {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    Array.isArray(obj.items) &&
    obj.items.every(isNavigationItem)
  );
}

function isContentBundle(obj: any): obj is ContentBundle {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    Object.keys(obj).every(key => typeof obj[key] === 'string')
  );
}

function isPlugin(obj: any): obj is Plugin {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof obj.name === 'string' &&
    typeof obj.version === 'string'
  );
}
```

## Zod Schemas

### Validation Schemas

```typescript
import { z } from 'zod';

const NavigationItemSchema = z.object({
  name: z.string(),
  type: z.enum(['page', 'section']),
  label: z.string(),
  items: z.array(z.lazy(() => NavigationItemSchema)).optional(),
  collapsed: z.boolean().optional(),
  url: z.string().url().optional()
});

const NavigationDataSchema = z.object({
  items: z.array(NavigationItemSchema)
});

const ContentBundleSchema = z.record(z.string(), z.string());

const PluginSchema = z.object({
  name: z.string(),
  version: z.string(),
  process: z.function().args(z.string()).returns(z.string()).optional(),
  transform: z.function().args(z.string()).returns(z.string()).optional(),
  validate: z.function().args(z.string()).returns(z.boolean()).optional(),
  beforeBuild: z.function().returns(z.void()).optional(),
  afterBuild: z.function().args(z.any()).returns(z.void()).optional()
});

const BuildOptionsSchema = z.object({
  appOutput: z.string().optional(),
  websiteOutput: z.string().optional(),
  staticOutput: z.string().optional(),
  includeContent: z.boolean().optional(),
  processor: z.object({
    process: z.function().args(z.string()).returns(z.string())
  }).optional(),
  plugins: z.array(PluginSchema).optional(),
  hooks: z.object({
    beforeBuild: z.function().args(z.string()).returns(z.union([z.void(), z.promise(z.void())])).optional(),
    afterBuild: z.function().args(z.any()).returns(z.union([z.void(), z.promise(z.void())])).optional(),
    onError: z.function().args(z.instanceof(Error)).returns(z.void()).optional()
  }).optional()
});
```

## Usage Examples

### Type-Safe Navigation

```typescript
import type { NavigationItem, NavigationData } from 'svelte-markdown-pages';

function validateNavigation(data: unknown): NavigationData {
  if (!isNavigationData(data)) {
    throw new Error('Invalid navigation data');
  }
  return data;
}

function findPage(items: NavigationItem[], name: string): NavigationItem | null {
  for (const item of items) {
    if (item.name === name && item.type === 'page') {
      return item;
    }
    if (item.items) {
      const found = findPage(item.items, name);
      if (found) return found;
    }
  }
  return null;
}
```

### Type-Safe Content Processing

```typescript
import type { ContentProcessor, ContentBundle } from 'svelte-markdown-pages';

function createProcessor(options: ProcessorOptions): ContentProcessor {
  return {
    process(content: string): string {
      let processed = content;
      
      if (options.markdown) {
        processed = processMarkdown(processed);
      }
      
      if (options.html) {
        processed = processHtml(processed);
      }
      
      if (options.custom) {
        processed = processCustom(processed);
      }
      
      return processed;
    }
  };
}

function validateContentBundle(bundle: unknown): ContentBundle {
  if (!isContentBundle(bundle)) {
    throw new Error('Invalid content bundle');
  }
  return bundle;
}
```

### Type-Safe Plugin Development

```typescript
import type { Plugin, PluginConfig } from 'svelte-markdown-pages';

function createPlugin(config: PluginConfig): Plugin {
  return {
    name: 'my-plugin',
    version: '1.0.0',
    process(content: string): string {
      if (!config.enabled) {
        return content;
      }
      
      // Apply plugin processing based on config.options
      return content;
    }
  };
}

function validatePlugin(plugin: unknown): Plugin {
  if (!isPlugin(plugin)) {
    throw new Error('Invalid plugin');
  }
  return plugin;
}
```

## Related

- [Builder API](./builder.md) - Content building and generation
- [Renderer API](./renderer.md) - Content rendering and navigation
---

# From docs/for-ai/rules.md:

# Basics for AI agents

# Git commits
Use imperative mood and use a prefix for the type of change.
Examples:
feat(auth): add user login
fix(payment): resolve gateway timeout
ci: update release workflow
docs: update README
dev: add the core and the client as aliases to the sveltkit config

## Commit types
Any product-related feature - "feature(name): description"
Any product-related fix - "fix(name): description"
Anything related to building and releasing (including fixes of CI) - "ci: description"
Anything related to testing - "tests: description"
Anything related to documentation - "docs: description"
Anything related to the build pipelines and dev convinience - "dev: description"
---

# From docs/for-ai/svelte.md:

New in SvelteKit 5:

# Runes

## Reactivity

Reactivity with `let x = "hello"` at component top-level is replaced with:

```js
let x: string = $state("hello")
```

This makes x reactive in the component, and also in any js functions that operate on it.

Don't use `$state<T>()` to pass the type. Always use `let x: Type =`. Variables declared with `let x = "hello"` are no longer reactive.

## Derived values

Old style:
```js
$: b = a + 1
```

New style:
```js
let b = $derived(a + 1)
```

Or for more complex use cases:
```js
let b = $derived.by(() => {
    // ... more complex logic
    return a + 1;
})
```

`$derived()` takes an expression. `$derived.by()` takes a function.

## Effect

```js
let a = $state(1);
let b = $state(2);
let c;

// This will run when the component is mounted, and for every updates to a and b.
$effect(() => {
    c = a + b;
});
```

Note: 
- Values read asynchronously (promises, setTimeout) inside `$effect` are not tracked.
- Values inside objects are not tracked directly inside `$effect`:

```js
// This will run once, because `state` is never reassigned (only mutated)
$effect(() => {
    state;
});

// This will run whenever `state.value` changes
$effect(() => {
    state.value;
});
```

An effect only depends on the values that it read the last time it ran.

```js
$effect(() => {
    if (a || b) {
        // ...
    }
});
```

If `a` was true, `b` was not read, and the effect won't run when `b` changes.

## Props

Old way to pass props to a component:
```js
export let a = "hello";
export let b;
```

New way:
```js
let {a = "hello", b, ...everythingElse} = $props()
```

`a` and `b` are reactive.

Types:
```js
let {a = "hello", b}: {a: string, b: number} = $props()
```

Note: Do NOT use this syntax for types:
```js
let { x = 42 } = $props<{ x?: string }>();  // ❌ Incorrect
```

# Slots and snippets

Instead of using `<slot />` in a component, you should now do:

```js
let { children } = $props()
// ...
{@render children()}  // This replaces <slot />
```

# Event Handling

In Svelte 5 the events do not use `on:event` syntax, they use `onevent` syntax.

In Svelte 5 `on:click` syntax is not allowed. Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the `on:` directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):

```svelte
<button onclick={() => count++}>
  clicks: {count}
</button>
```

`preventDefault` and `once` are removed in Svelte 5. Normal HTML event management is advised:

```svelte
<script>
  function once(fn) {
    return function(event) {
      if (fn) fn.call(this, event);
      fn = null;
    };
  }

  function preventDefault(fn) {
    return function(event) {
      event.preventDefault();
      fn.call(this, event);
    };
  }
</script>

<button onclick={once(preventDefault(handler))}>...</button>
```
---

# From docs/getting-started.md:

# Getting Started

Welcome to **svelte-markdown-pages** - a powerful, flexible solution for building documentation sites with distributed navigation structure for Svelte projects.

## What is svelte-markdown-pages?

svelte-markdown-pages is a standalone npm package that transforms your markdown content into a fully-featured documentation site. It provides:

- **Distributed Navigation**: Each folder defines its own structure with `.index.json` files
- **Multiple Output Formats**: App bundles, website navigation, and static HTML sites
- **Type-Safe**: Full TypeScript support with Zod validation
- **Framework Agnostic**: Svelte 5 components that work in any Svelte project
- **Flexible**: Point to any directory with markdown and `.index.json` files
- **Comprehensive Testing**: >90% test coverage with comprehensive test suite

## Key Features

### 🗂️ Distributed Navigation
Organize your documentation with a distributed navigation system. Each folder can define its own structure using `.index.json` files, making it easy to maintain large documentation sites.

### 📦 Multiple Output Formats
Generate different outputs for different use cases:
- **App bundles** for integration into existing Svelte applications
- **Website navigation** for standalone documentation sites
- **Static HTML sites** for deployment to any hosting platform

### 🔧 Type-Safe Development
Built with TypeScript and Zod validation, providing excellent developer experience with full type safety and runtime validation.

### 🎨 Framework Agnostic
Svelte 5 components that work seamlessly in any Svelte project, including SvelteKit applications.

### ⚡ Flexible & Extensible
Point to any directory with markdown content and `.index.json` files. Customize everything from styling to content processing with custom processors.

## Quick Start

### 1. Install the Package

```bash
npm install svelte-markdown-pages
```

### 2. Create Your Content Structure

Create a directory with your markdown content and `.index.json` files:

```
my-docs/
├── .index.json
├── getting-started.md
└── guides/
    ├── .index.json
    └── installation.md
```

### 3. Define Navigation

**Root level** (`my-docs/.index.json`):
```json
{
  "items": [
    { "name": "getting-started", "type": "page", "label": "Getting Started" },
    { "name": "guides", "type": "section", "label": "Guides" }
  ]
}
```

**Section level** (`my-docs/guides/.index.json`):
```json
{
  "items": [
    { "name": "installation", "type": "page", "label": "Installation" }
  ]
}
```

### 4. Build Your Documentation

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

await buildPages('./my-docs', {
  appOutput: './src/lib/content',
  includeContent: true
});
```

### 5. Use in Your App

```typescript
import { NavigationTree, loadContent } from 'svelte-markdown-pages/renderer';
import navigationData from './src/lib/content/navigation.json';
import contentBundle from './src/lib/content/content.json';

const navigation = new NavigationTree(navigationData);
const content = await loadContent('getting-started.md', contentBundle);
```

## Use Cases

### Documentation Sites
Perfect for project documentation, API references, and user guides.

### Blog Systems
Create blog systems with hierarchical organization and easy content management.

### Knowledge Bases
Build comprehensive knowledge bases with distributed content management.

### Static Sites
Generate complete static HTML sites for deployment to any hosting platform.

## What's Next?

Ready to get started? Check out the [Installation](./guides/installation.md) guide to set up your first documentation site!

## Examples

- **This Website**: Built using svelte-markdown-pages itself
- **Example Project**: See the `packages/examples` directory for a complete working example
- **Test Suite**: Comprehensive examples in the `packages/tests` directory
---

# From docs/guides/.index.json:

{
  "items": [
    { "name": "installation", "type": "page", "label": "Installation" },
    { "name": "configuration", "type": "page", "label": "Configuration" },
    { "name": "advanced", "type": "section", "label": "Advanced" }
  ]
}
---

# From docs/guides/advanced/.index.json:

{
  "items": [
    { "name": "customization", "type": "page", "label": "Customization" }
  ]
}
---

# From docs/guides/advanced/customization.md:

# Advanced Customization

Learn how to customize svelte-markdown-pages for your specific needs with advanced configuration options.

## Custom Components

You can create custom components to extend the functionality of your documentation:

```svelte
<!-- src/lib/components/CustomComponent.svelte -->
<script lang="ts">
	let { content } = $props<{ content: string }>();
</script>

<div class="custom-component">
	{@html content}
</div>

<style>
	.custom-component {
		background: #f8f9fa;
		border: 1px solid #e9ecef;
		border-radius: 8px;
		padding: 1rem;
		margin: 1rem 0;
	}
</style>
```

## Custom Processors

Create custom content processors for advanced transformations:

```typescript
const customProcessor = {
	process(content: string): string {
		// Replace custom syntax with HTML
		return content
			.replace(/:::(.+?):::/g, '<CustomComponent content="$1" />')
			.replace(/\[\[(.+?)\]\]/g, '<InternalLink href="$1" />');
	}
};

await buildPages('./docs', {
  appOutput: './src/lib/content',
  processor: customProcessor
});
```

## Custom Styling

### CSS Customization

Override default styles with your own CSS:

```css
/* Custom documentation styles */
.docs-content {
	font-family: 'Inter', sans-serif;
	line-height: 1.7;
}

.docs-content h1 {
	color: #1a202c;
	border-bottom: 3px solid #3182ce;
}

.docs-content code {
	background: #edf2f7;
	color: #2d3748;
	font-weight: 500;
}

.docs-content pre {
	background: #2d3748;
	border-radius: 12px;
	box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
```

### Theme System

Create theme variations:

```typescript
const themes = {
	light: {
		background: '#ffffff',
		text: '#2d3748',
		primary: '#3182ce',
		secondary: '#718096'
	},
	dark: {
		background: '#1a202c',
		text: '#e2e8f0',
		primary: '#63b3ed',
		secondary: '#a0aec0'
	}
};
```

## Custom Navigation

### Custom Navigation Components

Create custom navigation components:

```svelte
<!-- src/lib/components/CustomSidebar.svelte -->
<script lang="ts">
	import type { NavigationItem } from 'svelte-markdown-pages';
	
	let { items, currentPage } = $props<{
		items: NavigationItem[];
		currentPage: string;
	}>();
	
	function renderItem(item: NavigationItem): string {
		if (item.type === 'section') {
			return `
				<div class="nav-section">
					<h3 class="nav-section-title">${item.label}</h3>
					${item.items?.map(renderItem).join('') || ''}
				</div>
			`;
		}
		
		const isActive = currentPage === item.name + '.md';
		return `
			<a href="/docs/${item.name}" class="nav-item ${isActive ? 'active' : ''}">
				${item.label}
			</a>
		`;
	}
</script>

<nav class="custom-sidebar">
	{@html items.map(renderItem).join('')}
</nav>

<style>
	.custom-sidebar {
		background: #f7fafc;
		padding: 1.5rem;
		border-right: 1px solid #e2e8f0;
	}
	
	.nav-section-title {
		font-size: 0.875rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		color: #718096;
		margin: 1.5rem 0 0.75rem 0;
	}
	
	.nav-item {
		display: block;
		padding: 0.5rem 0.75rem;
		color: #4a5568;
		text-decoration: none;
		border-radius: 6px;
		margin: 0.25rem 0;
		transition: all 0.2s;
	}
	
	.nav-item:hover {
		background: #edf2f7;
		color: #2d3748;
	}
	
	.nav-item.active {
		background: #3182ce;
		color: white;
	}
</style>
```

## Custom Layouts

### Page Layouts

Create different layouts for different types of content:

```svelte
<!-- src/lib/layouts/DocumentationLayout.svelte -->
<script lang="ts">
	let { children, title, sidebar } = $props<{
		children: any;
		title: string;
		sidebar: any;
	}>();
</script>

<div class="doc-layout">
	<header class="doc-header">
		<h1>{title}</h1>
	</header>
	
	<div class="doc-body">
		<aside class="doc-sidebar">
			{@render sidebar()}
		</aside>
		
		<main class="doc-content">
			{@render children()}
		</main>
	</div>
</div>

<style>
	.doc-layout {
		min-height: 100vh;
		display: flex;
		flex-direction: column;
	}
	
	.doc-header {
		background: #2d3748;
		color: white;
		padding: 1rem 2rem;
	}
	
	.doc-body {
		display: flex;
		flex: 1;
	}
	
	.doc-sidebar {
		width: 280px;
		background: #f7fafc;
		border-right: 1px solid #e2e8f0;
	}
	
	.doc-content {
		flex: 1;
		padding: 2rem;
	}
</style>
```

## Custom Markdown Extensions

### Syntax Extensions

Extend markdown syntax with custom processors:

```typescript
const markdownExtensions = {
	// Custom admonition blocks
	admonition: {
		pattern: /^:::(\w+)\n([\s\S]*?)\n:::$/gm,
		replacement: (match: string, type: string, content: string) => {
			const icons = {
				info: 'ℹ️',
				warning: '⚠️',
				error: '❌',
				success: '✅'
			};
			
			return `
				<div class="admonition admonition-${type}">
					<div class="admonition-header">
						${icons[type as keyof typeof icons] || '📝'} ${type.charAt(0).toUpperCase() + type.slice(1)}
					</div>
					<div class="admonition-content">
						${content}
					</div>
				</div>
			`;
		}
	},
	
	// Custom callout blocks
	callout: {
		pattern: /^\[\[(.+?)\]\]\n([\s\S]*?)\n\[\[\/\]\]$/gm,
		replacement: (match: string, title: string, content: string) => {
			return `
				<div class="callout">
					<div class="callout-title">${title}</div>
					<div class="callout-content">
						${content}
					</div>
				</div>
			`;
		}
	}
};

const processor = {
	process(content: string): string {
		let processed = content;
		
		// Apply custom extensions
		Object.values(markdownExtensions).forEach(extension => {
			processed = processed.replace(extension.pattern, extension.replacement);
		});
		
		return processed;
	}
};
```

## Custom Build Process

### Build Hooks

Add custom build hooks for advanced processing:

```typescript
const buildHooks = {
	beforeBuild: async (contentPath: string) => {
		console.log('Starting build for:', contentPath);
		// Pre-processing tasks
	},
	
	afterBuild: async (result: any) => {
		console.log('Build completed:', result);
		// Post-processing tasks
	},
	
	onError: (error: Error) => {
		console.error('Build error:', error);
		// Error handling
	}
};

await buildPages('./docs', {
  appOutput: './src/lib/content',
  hooks: buildHooks
});
```

## Performance Optimization

### Lazy Loading

Implement lazy loading for large documentation sites:

```typescript
const lazyProcessor = {
	process(content: string): string {
		// Add lazy loading attributes to images
		return content.replace(
			/<img([^>]+)>/g,
			'<img$1 loading="lazy">'
		);
	}
};
```

### Code Splitting

Split large content into smaller chunks:

```typescript
const chunkProcessor = {
	process(content: string): string {
		// Split content into sections
		const sections = content.split(/(?=^#{1,3}\s)/m);
		
		return sections.map((section, index) => {
			if (index === 0) return section;
			return `<section data-chunk="${index}">${section}</section>`;
		}).join('');
	}
};
```

## Next Steps

Now that you understand advanced customization, explore:


- [API Reference](../api/builder.md) - Complete API documentation
- [Examples](../../packages/examples) - Working examples
---

# From docs/guides/configuration.md:

# Configuration

Learn how to configure svelte-markdown-pages for your project with detailed options and examples.

## Basic Configuration

The simplest way to build your documentation:

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true
});
```

## Build Options

### `appOutput`
Directory where app-specific files will be generated.

```typescript
await buildPages('./docs', {
  appOutput: './src/lib/content'
});
```

**Generated files:**
- `navigation.json` - Navigation structure
- `content.json` - Content bundle (if `includeContent: true`)

### `websiteOutput`
Directory where website-specific files will be generated.

```typescript
await buildPages('./docs', {
  websiteOutput: './src/lib/content'
});
```

**Generated files:**
- `navigation.json` - Navigation structure
- `content.json` - Content bundle (if `includeContent: true`)

### `includeContent`
Whether to include content in the output bundle.

```typescript
await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true  // Default: false
});
```

### `staticOutput`
Directory for static site generation.

```typescript
await buildPages('./docs', {
  staticOutput: './dist'
});
```

## Advanced Options

### Custom Processors

You can provide custom content processors for advanced transformations:

```typescript
const processor = {
  process(content: string): string {
    // Add table of contents
    return addTableOfContents(content);
  }
};

const result = await buildPages('./docs', {
  appOutput: './src/lib/content',
  processor
});
```

 

## Static Site Generation

Generate a complete static HTML site:

```typescript
import { generateStaticSite } from 'svelte-markdown-pages/builder';

const result = await generateStaticSite('./docs', './dist', {
  title: 'My Documentation',
  baseUrl: 'https://example.com',
  includeIndex: true
});
```

### Static Site Options

#### `title`
Site title for the generated HTML.

```typescript
await generateStaticSite('./docs', './dist', {
  title: 'My Awesome Documentation'
});
```

#### `baseUrl`
Base URL for the site (used for absolute links).

```typescript
await generateStaticSite('./docs', './dist', {
  baseUrl: 'https://docs.example.com'
});
```

#### `css`
Custom CSS content to include in the generated HTML.

```typescript
await generateStaticSite('./docs', './dist', {
  css: `
    body { font-family: 'Inter', sans-serif; }
    .docs-content { max-width: 800px; margin: 0 auto; }
  `
});
```

#### `js`
Custom JavaScript content to include in the generated HTML.

```typescript
await generateStaticSite('./docs', './dist', {
  js: `
    // Add syntax highlighting
    hljs.highlightAll();
  `
});
```

#### `includeIndex`
Whether to generate an index page.

```typescript
await generateStaticSite('./docs', './dist', {
  includeIndex: true  // Default: false
});
```

#### `indexTitle`
Title for the generated index page.

```typescript
await generateStaticSite('./docs', './dist', {
  includeIndex: true,
  indexTitle: 'Documentation Home'
});
```

## CLI Usage

### Build Command

Build documentation for app integration:

```bash
npx svelte-markdown-pages build <content-path> --output <output-path>
```

**Options:**
- `--output`: Output directory (required)

**Examples:**
```bash
# Basic build
npx svelte-markdown-pages build ./docs --output ./src/lib/content
```

### Static Command

Generate a complete static HTML site:

```bash
npx svelte-markdown-pages static <content-path> --output <output-path>
```

**Options:**
- `--output`: Output directory (required)

**Examples:**
```bash
# Basic static site
npx svelte-markdown-pages static ./docs --output ./dist
```

## Environment Variables

Configure behavior using environment variables:

### `SMP_DEBUG`
Enable debug logging.

```bash
SMP_DEBUG=1 npx svelte-markdown-pages build ./docs
```

### `SMP_VERBOSE`
Enable verbose output.

```bash
SMP_VERBOSE=1 npx svelte-markdown-pages build ./docs
```

## Configuration Files

### Package.json Scripts

Add build scripts to your `package.json`:

```json
{
  "scripts": {
    "build:docs": "svelte-markdown-pages build ./docs --output ./src/lib/content --include-content",
    "build:static": "svelte-markdown-pages static ./docs ./dist --title \"My Documentation\" --include-index",
    "dev:docs": "npm run build:docs && npm run dev"
  }
}
```

### Build Scripts

Create dedicated build scripts for complex configurations:

```typescript
// scripts/build-docs.js
import { buildPages } from 'svelte-markdown-pages/builder';
import { syntaxHighlightingPlugin } from 'svelte-markdown-pages/plugins';

const processor = {
  process(content: string): string {
    // Custom processing logic
    return content.replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>');
  }
};

await buildPages('./docs', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true,
  processor,
  plugins: [syntaxHighlightingPlugin]
});
```

## Error Handling

The builder functions throw errors for common issues:

```typescript
try {
  const result = await buildPages('./docs');
} catch (error) {
  if (error.code === 'ENOENT') {
    console.error('Content directory not found');
  } else if (error.code === 'INVALID_INDEX') {
    console.error('Invalid .index.json file');
  } else {
    console.error('Build failed:', error.message);
  }
}
```

## Performance Optimization

### Large Documentation Sites

For large documentation sites, consider:

```typescript
// Build only what you need
await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: false,  // Don't include content if not needed
  processor: {
    process(content: string): string {
      // Optimize content processing
      return content;
    }
  }
});
```

### Caching

Implement caching for faster rebuilds:

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';
import { existsSync, readFileSync } from 'fs';

const cacheFile = './.docs-cache.json';

// Check if cache exists and is valid
if (existsSync(cacheFile)) {
  const cache = JSON.parse(readFileSync(cacheFile, 'utf8'));
  // Use cache if valid
}

const result = await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true
});

// Save cache
// ...
```

## Next Steps

Now that you understand configuration, explore:

- [Advanced Customization](./advanced/customization.md) - Learn about custom components and styling

- [API Reference](../api/builder.md) - Complete API documentation
---

# From docs/guides/installation.md:

# Installation

Follow this guide to install and set up svelte-markdown-pages in your project.

## Prerequisites

Before installing svelte-markdown-pages, make sure you have:

- **Node.js 18+** - Required for modern JavaScript features
- **npm or yarn** - Package manager for installing dependencies
- **Svelte 5+** - The package is designed for Svelte 5 and later

## Quick Install

Install the package using npm:

```bash
npm install svelte-markdown-pages
```

Or using yarn:

```bash
yarn add svelte-markdown-pages
```

## Manual Setup

### 1. Create a New SvelteKit Project (Optional)

If you're starting from scratch, create a new SvelteKit project:

```bash
npm create svelte@latest my-docs-site
cd my-docs-site
npm install
```

### 2. Install svelte-markdown-pages

```bash
npm install svelte-markdown-pages
```

### 3. Set Up Your Content Structure

Create a directory for your documentation content:

```bash
mkdir docs
```

### 4. Create Your First Content

Create a basic documentation structure:

```bash
# Create the main index file
echo '{
  "items": [
    { "name": "getting-started", "type": "page", "label": "Getting Started" }
  ]
}' > docs/.index.json

# Create your first markdown file
echo '# Getting Started

Welcome to your documentation site!

This is your first page created with svelte-markdown-pages.' > docs/getting-started.md
```

### 5. Build Your Documentation

Create a build script in your `package.json`:

```json
{
  "scripts": {
    "build:docs": "node -e \"import('svelte-markdown-pages/builder').then(({buildPages}) => buildPages('./docs', {appOutput: './src/lib/content', includeContent: true}))\""
  }
}
```

Or create a build script file:

```typescript
// scripts/build-docs.js
import { buildPages } from 'svelte-markdown-pages/builder';

await buildPages('./docs', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  includeContent: true
});
```

### 6. Use in Your SvelteKit App

Create a documentation page in your SvelteKit app:

```svelte
<!-- src/routes/docs/+page.svelte -->
<script lang="ts">
  import { NavigationTree, loadContent } from 'svelte-markdown-pages/renderer';
  import navigationData from '$lib/content/navigation.json';
  import contentBundle from '$lib/content/content.json';
  
  let navigation = $state(new NavigationTree(navigationData));
  let currentPage = $state("getting-started.md");
  let pageContent = $state<string | null>(null);
  
  $effect(() => {
    if (currentPage && contentBundle) {
      loadContent(currentPage, contentBundle).then(content => {
        pageContent = content;
      });
    }
  });
</script>

<div class="docs-layout">
  <nav class="sidebar">
    <!-- Navigation will go here -->
  </nav>
  <main class="content">
    {@html pageContent || 'Loading...'}
  </main>
</div>
```

## Content Structure

### Basic Structure

Your documentation should follow this structure:

```
docs/
├── .index.json              # Root navigation
├── getting-started.md        # Getting started page
├── guides/
│   ├── .index.json          # Guides section navigation
│   ├── installation.md      # Installation guide
│   └── configuration.md     # Configuration guide
└── api/
    ├── .index.json          # API section navigation
    └── reference.md         # API reference
```

### Index.json Format

Each `.index.json` file defines the navigation structure for that directory:

```json
{
  "items": [
    {
      "name": "page-name",
      "type": "page",
      "label": "Page Display Name"
    },
    {
      "name": "section-name",
      "type": "section",
      "label": "Section Display Name"
    }
  ]
}
```

### Item Properties

- `name`: File/directory name (without extension)
- `type`: Either `"page"` or `"section"`
- `label`: Display label for navigation
- `collapsed`: Optional boolean to collapse sections by default
- `url`: Optional external URL

## Build Configuration

### Basic Build

```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true
});
```

### Advanced Build Options

```typescript
await buildPages('./docs', {
  appOutput: './src/lib/content',
  websiteOutput: './src/lib/content',
  staticOutput: './dist',
  includeContent: true,
  processor: customProcessor,
  
});
```

## CLI Usage

You can also use the CLI for quick builds:

```bash
# Build for app integration
npx svelte-markdown-pages build ./docs --output ./src/lib/content

# Generate static site
npx svelte-markdown-pages static ./docs --output ./dist
```

## Next Steps

Now that you have svelte-markdown-pages installed, check out:

- [Configuration](./configuration.md) - Learn about build options and customization
- [API Reference](../api/builder.md) - Complete API documentation
- [Examples](../../packages/examples) - Working examples in the examples package

## Troubleshooting

### Common Issues

**Module not found errors**: Make sure you're using Node.js 18+ and have installed the package correctly.

**Build errors**: Check that your `.index.json` files are valid JSON and follow the correct format.

**Content not loading**: Verify that your markdown files exist and are referenced correctly in the navigation.

### Getting Help

- Check the [API Reference](../api/builder.md) for detailed documentation
- Look at the [examples](../../packages/examples) for working implementations
- Review the [test suite](../../packages/tests) for usage patterns
---

# From docs/proposals/.index.json:

{
  "items": [
    { "name": "plugins", "type": "page", "label": "Plugin System" },
    { "name": "search", "type": "page", "label": "Semantic Search" },
    { "name": "search-quick-reference", "type": "page", "label": "Search Quick Reference" },
    { "name": "client-side-search", "type": "page", "label": "Client-Side Search" },
    { "name": "hybrid-search", "type": "page", "label": "Hybrid Search" }
  ]
}
---

# From docs/proposals/client-side-search.md:

# Client-Side Search for Static Websites

A comprehensive guide for implementing search functionality in svelte-markdown-pages websites using client-side JavaScript solutions that work entirely in the browser.

## Overview

This guide focuses on search solutions that:
- ✅ Work entirely in the browser (no server required)
- ✅ Are open source and free
- ✅ Can be embedded in static websites
- ✅ Don't require external services or APIs
- ✅ Index content at build time

## Search Solutions

### 1. **Lunr.js** (Most Popular)

**Best for**: Small to medium documentation sites
**Bundle Size**: ~40KB gzipped
**Performance**: Excellent for < 1000 documents

#### Installation
```bash
npm install lunr
```

#### Basic Implementation
```typescript
// src/lib/search.ts
import lunr from 'lunr';

export interface SearchDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  section?: string;
  tags?: string[];
}

export class LunrSearch {
  private index: lunr.Index;
  private documents: SearchDocument[];

  constructor(documents: SearchDocument[]) {
    this.documents = documents;
    this.index = lunr(function() {
      this.ref('id');
      this.field('title', { boost: 10 });
      this.field('content', { boost: 5 });
      this.field('section', { boost: 3 });
      this.field('tags', { boost: 2 });

      documents.forEach(doc => {
        this.add(doc);
      });
    });
  }

  search(query: string, limit = 10): SearchDocument[] {
    if (!query.trim()) return [];
    
    const results = this.index.search(query);
    return results
      .slice(0, limit)
      .map(result => this.documents.find(doc => doc.id === result.ref)!)
      .filter(Boolean);
  }

  getDocument(id: string): SearchDocument | undefined {
    return this.documents.find(doc => doc.id === id);
  }
}
```

#### Svelte Component
```svelte
<!-- src/lib/components/LunrSearch.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { LunrSearch, type SearchDocument } from '$lib/search';
  
  export let documents: SearchDocument[] = [];
  export let placeholder = 'Search documentation...';
  export let maxResults = 10;
  
  let searchQuery = '';
  let searchResults: SearchDocument[] = [];
  let searchInstance: LunrSearch;
  let isSearching = false;
  let showResults = false;
  
  const dispatch = createEventDispatcher();
  
  // Initialize search index
  $: {
    if (documents.length > 0 && !searchInstance) {
      searchInstance = new LunrSearch(documents);
    }
  }
  
  // Perform search with debouncing
  let searchTimeout: number;
  $: {
    if (searchInstance && searchQuery.trim()) {
      clearTimeout(searchTimeout);
      isSearching = true;
      showResults = true;
      
      searchTimeout = setTimeout(() => {
        searchResults = searchInstance.search(searchQuery, maxResults);
        isSearching = false;
      }, 300);
    } else {
      searchResults = [];
      showResults = false;
    }
  }
  
  function handleResultClick(result: SearchDocument) {
    dispatch('resultClick', result);
    showResults = false;
    searchQuery = '';
  }
  
  function handleInputFocus() {
    if (searchResults.length > 0) {
      showResults = true;
    }
  }
  
  function handleClickOutside(event: MouseEvent) {
    const target = event.target as HTMLElement;
    if (!target.closest('.search-container')) {
      showResults = false;
    }
  }
</script>

<svelte:window on:click={handleClickOutside} />

<div class="search-container">
  <div class="search-input-wrapper">
    <input
      type="text"
      bind:value={searchQuery}
      {placeholder}
      on:focus={handleInputFocus}
      class="search-input"
      aria-label="Search documentation"
    />
    {#if isSearching}
      <div class="search-spinner">🔍</div>
    {/if}
  </div>
  
  {#if showResults && searchResults.length > 0}
    <div class="search-results" role="listbox">
      {#each searchResults as result (result.id)}
        <div 
          class="search-result"
          on:click={() => handleResultClick(result)}
          role="option"
          tabindex="0"
          on:keydown={(e) => e.key === 'Enter' && handleResultClick(result)}
        >
          <div class="result-header">
            <h4 class="result-title">{result.title}</h4>
            {#if result.section}
              <span class="result-section">{result.section}</span>
            {/if}
          </div>
          <p class="result-excerpt">
            {result.content.substring(0, 150)}
            {result.content.length > 150 ? '...' : ''}
          </p>
          {#if result.tags && result.tags.length > 0}
            <div class="result-tags">
              {#each result.tags as tag}
                <span class="tag">{tag}</span>
              {/each}
            </div>
          {/if}
        </div>
      {/each}
    </div>
  {:else if showResults && searchQuery.trim() && !isSearching}
    <div class="no-results">
      <p>No results found for "{searchQuery}"</p>
      <p class="no-results-suggestions">
        Try different keywords or check your spelling
      </p>
    </div>
  {/if}
</div>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
  }
  
  .search-input-wrapper {
    position: relative;
  }
  
  .search-input {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.2s;
  }
  
  .search-input:focus {
    outline: none;
    border-color: #3b82f6;
  }
  
  .search-spinner {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: translateY(-50%) rotate(0deg); }
    to { transform: translateY(-50%) rotate(360deg); }
  }
  
  .search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    max-height: 500px;
    overflow-y: auto;
    z-index: 1000;
    margin-top: 4px;
  }
  
  .search-result {
    padding: 16px;
    border-bottom: 1px solid #f1f5f9;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  
  .search-result:hover,
  .search-result:focus {
    background: #f8fafc;
    outline: none;
  }
  
  .search-result:last-child {
    border-bottom: none;
  }
  
  .result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .result-title {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #1e293b;
  }
  
  .result-section {
    font-size: 12px;
    color: #64748b;
    background: #f1f5f9;
    padding: 2px 8px;
    border-radius: 12px;
    white-space: nowrap;
  }
  
  .result-excerpt {
    margin: 0 0 8px 0;
    font-size: 14px;
    color: #475569;
    line-height: 1.5;
  }
  
  .result-tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }
  
  .tag {
    font-size: 11px;
    color: #3b82f6;
    background: #eff6ff;
    padding: 2px 6px;
    border-radius: 4px;
  }
  
  .no-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    padding: 24px;
    text-align: center;
    margin-top: 4px;
    z-index: 1000;
  }
  
  .no-results p {
    margin: 0 0 8px 0;
    color: #64748b;
  }
  
  .no-results-suggestions {
    font-size: 14px;
    color: #94a3b8;
  }
</style>
```

### 2. **FlexSearch** (Fastest)

**Best for**: Large datasets, performance-critical applications
**Bundle Size**: ~15KB gzipped
**Performance**: Excellent for > 1000 documents

#### Installation
```bash
npm install flexsearch
```

#### Implementation
```typescript
// src/lib/flexsearch.ts
import FlexSearch from 'flexsearch';

export class FlexSearchEngine {
  private index: FlexSearch.Index;
  private documents: SearchDocument[];

  constructor(documents: SearchDocument[]) {
    this.documents = documents;
    this.index = new FlexSearch.Index({
      tokenize: 'forward',
      resolution: 9,
      cache: true
    });

    // Index documents
    documents.forEach((doc, id) => {
      this.index.add(id, `${doc.title} ${doc.content} ${doc.section || ''}`);
    });
  }

  async search(query: string, limit = 10): Promise<SearchDocument[]> {
    if (!query.trim()) return [];
    
    const results = await this.index.search(query, {
      limit,
      suggest: true
    });
    
    return results.map(id => this.documents[id as number]);
  }
}
```

### 3. **MiniSearch** (Lightweight)

**Best for**: Small sites, minimal bundle size
**Bundle Size**: ~20KB gzipped
**Performance**: Good for < 500 documents

#### Installation
```bash
npm install minisearch
```

#### Implementation
```typescript
// src/lib/minisearch.ts
import MiniSearch from 'minisearch';

export class MiniSearchEngine {
  private search: MiniSearch;

  constructor(documents: SearchDocument[]) {
    this.search = new MiniSearch({
      fields: ['title', 'content', 'section', 'tags'],
      storeFields: ['id', 'url'],
      searchOptions: {
        boost: { title: 10, section: 3, tags: 2 },
        fuzzy: 0.2,
        prefix: true
      }
    });

    this.search.addAll(documents);
  }

  search(query: string, limit = 10): SearchDocument[] {
    if (!query.trim()) return [];
    
    return this.search.search(query, {
      limit,
      fuzzy: 0.2
    });
  }
}
```

### 4. **Fuse.js** (Fuzzy Search)

**Best for**: Fuzzy matching, typo tolerance
**Bundle Size**: ~25KB gzipped
**Performance**: Good for < 1000 documents

#### Installation
```bash
npm install fuse.js
```

#### Implementation
```typescript
// src/lib/fuse-search.ts
import Fuse from 'fuse.js';

export class FuseSearch {
  private fuse: Fuse<SearchDocument>;

  constructor(documents: SearchDocument[]) {
    this.fuse = new Fuse(documents, {
      keys: [
        { name: 'title', weight: 0.7 },
        { name: 'content', weight: 0.3 },
        { name: 'section', weight: 0.5 }
      ],
      threshold: 0.3,
      includeScore: true,
      minMatchCharLength: 2
    });
  }

  search(query: string, limit = 10): SearchDocument[] {
    if (!query.trim()) return [];
    
    return this.fuse.search(query, { limit })
      .map(result => result.item);
  }
}
```

## Content Indexing with svelte-markdown-pages

### Build-Time Index Generation

```typescript
// scripts/build-search-index.ts
import { buildPages } from 'svelte-markdown-pages/builder';
import { writeFileSync } from 'fs';
import { join } from 'path';

export interface SearchDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  section?: string;
  tags?: string[];
  lastModified?: string;
}

function extractTitle(content: string): string {
  const titleMatch = content.match(/^#\s+(.+)$/m);
  return titleMatch ? titleMatch[1].trim() : 'Untitled';
}

function extractTags(content: string): string[] {
  const tagMatch = content.match(/^tags?:\s*(.+)$/mi);
  if (tagMatch) {
    return tagMatch[1].split(',').map(tag => tag.trim());
  }
  return [];
}

function cleanContent(content: string): string {
  return content
    .replace(/^#+\s+/gm, '') // Remove headings
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Remove links
    .replace(/`([^`]+)`/g, '$1') // Remove inline code
    .replace(/```[\s\S]*?```/g, '') // Remove code blocks
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1') // Remove images
    .replace(/^\s*[-*+]\s+/gm, '') // Remove list markers
    .replace(/^\s*\d+\.\s+/gm, '') // Remove numbered lists
    .replace(/\n{3,}/g, '\n\n') // Normalize line breaks
    .trim();
}

export async function buildSearchIndex(contentPath: string): Promise<SearchDocument[]> {
  const result = await buildPages(contentPath, {
    includeContent: true
  });
  
  const documents: SearchDocument[] = [];
  
  function processItems(items: any[], parentPath = '') {
    for (const item of items) {
      if (item.type === 'page' && item.path) {
        const content = result.content?.[item.path];
        if (content) {
          const title = extractTitle(content);
          const tags = extractTags(content);
          const cleanContent = cleanContent(content);
          
          documents.push({
            id: item.path,
            title,
            content: cleanContent,
            url: `/${item.path.replace(/\.md$/, '')}`,
            section: parentPath || undefined,
            tags: tags.length > 0 ? tags : undefined,
            lastModified: new Date().toISOString()
          });
        }
      } else if (item.items) {
        const sectionPath = parentPath ? `${parentPath} > ${item.label}` : item.label;
        processItems(item.items, sectionPath);
      }
    }
  }
  
  processItems(result.navigation.items);
  return documents;
}

// Build script
async function main() {
  const documents = await buildSearchIndex('./docs');
  
  // Write search index
  writeFileSync(
    join(process.cwd(), 'src/lib/search-index.json'),
    JSON.stringify(documents, null, 2)
  );
  
  console.log(`✅ Generated search index with ${documents.length} documents`);
}

main().catch(console.error);
```

### Package.json Integration

```json
{
  "scripts": {
    "build:search": "node scripts/build-search-index.js",
    "build": "npm run build:docs && npm run build:search"
  }
}
```

## SvelteKit Integration

### Layout Integration

```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import Search from '$lib/components/LunrSearch.svelte';
  import searchIndex from '$lib/search-index.json';
  import { goto } from '$app/navigation';
  
  function handleSearchResult(event: CustomEvent) {
    const result = event.detail;
    goto(result.url);
  }
</script>

<header>
  <Search 
    documents={searchIndex} 
    on:resultClick={handleSearchResult}
  />
</header>

<main>
  <slot />
</main>
```

### Search Page

```svelte
<!-- src/routes/search/+page.svelte -->
<script lang="ts">
  import Search from '$lib/components/LunrSearch.svelte';
  import searchIndex from '$lib/search-index.json';
  import { goto } from '$app/navigation';
  
  function handleSearchResult(event: CustomEvent) {
    const result = event.detail;
    goto(result.url);
  }
</script>

<svelte:head>
  <title>Search Documentation</title>
</svelte:head>

<div class="search-page">
  <h1>Search Documentation</h1>
  <p>Find what you're looking for in our documentation.</p>
  
  <Search 
    documents={searchIndex} 
    on:resultClick={handleSearchResult}
    maxResults={20}
  />
  
  <div class="search-stats">
    <p>Searching through {searchIndex.length} documents</p>
  </div>
</div>

<style>
  .search-page {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
  }
  
  .search-stats {
    margin-top: 2rem;
    text-align: center;
    color: #64748b;
  }
</style>
```

## Performance Optimization

### 1. **Lazy Loading**

```typescript
// Lazy load search index
export async function loadSearchIndex() {
  if (typeof window !== 'undefined') {
    const { default: searchIndex } = await import('$lib/search-index.json');
    return searchIndex;
  }
  return [];
}
```

### 2. **Search Index Compression**

```typescript
// Compress search index for smaller bundle
function compressSearchIndex(documents: SearchDocument[]) {
  return documents.map(doc => ({
    i: doc.id,
    t: doc.title,
    c: doc.content.substring(0, 500), // Limit content length
    u: doc.url,
    s: doc.section
  }));
}
```

### 3. **Caching**

```typescript
// Cache search results
const searchCache = new Map<string, SearchDocument[]>();

function cachedSearch(query: string, searchFn: (q: string) => SearchDocument[]) {
  if (searchCache.has(query)) {
    return searchCache.get(query)!;
  }
  
  const results = searchFn(query);
  searchCache.set(query, results);
  return results;
}
```

## Comparison Table

| Solution | Bundle Size | Performance | Features | Best For |
|----------|-------------|-------------|----------|----------|
| **Lunr.js** | ~40KB | ⭐⭐⭐⭐ | Full-text, fuzzy, boosting | General use |
| **FlexSearch** | ~15KB | ⭐⭐⭐⭐⭐ | Fast, memory efficient | Large datasets |
| **MiniSearch** | ~20KB | ⭐⭐⭐ | Simple, lightweight | Small sites |
| **Fuse.js** | ~25KB | ⭐⭐⭐ | Fuzzy matching | Typo tolerance |

## Recommendations

### **Choose Lunr.js if:**
- You want the most mature and feature-rich solution
- You need advanced search features (boosting, fuzzy search)
- You have a medium-sized site (100-1000 documents)

### **Choose FlexSearch if:**
- You have a large site (> 1000 documents)
- Performance is critical
- You want the smallest bundle size

### **Choose MiniSearch if:**
- You have a small site (< 100 documents)
- You want simplicity
- Bundle size is important

### **Choose Fuse.js if:**
- You need excellent fuzzy matching
- Typo tolerance is important
- You want simple configuration

## Implementation Checklist

- [ ] Choose search solution based on requirements
- [ ] Set up content indexing in build process
- [ ] Create search component
- [ ] Integrate with layout/navigation
- [ ] Add search page (optional)
- [ ] Test search functionality
- [ ] Optimize performance
- [ ] Add keyboard navigation
- [ ] Test accessibility

This guide provides everything needed to implement client-side search that works entirely in the browser without any external dependencies or services!
---

# From docs/proposals/hybrid-search.md:

# Hybrid Search: Semantic + Literal Search

A comprehensive guide for implementing hybrid search that combines semantic search with literal/full-text search to provide the best search experience for svelte-markdown-pages websites.

## Overview

Hybrid search combines the strengths of both approaches:
- **Semantic Search**: Understands meaning and context (AI-powered)
- **Literal Search**: Exact keyword matching and fuzzy search
- **Result Fusion**: Intelligently combines results from both approaches

## Why Hybrid Search?

### **Semantic Search Strengths:**
- ✅ Understands synonyms and related concepts
- ✅ Handles natural language queries
- ✅ Finds relevant content even without exact keywords
- ✅ Better for complex, conceptual searches

### **Literal Search Strengths:**
- ✅ Fast and reliable
- ✅ Exact keyword matching
- ✅ Handles technical terms and code
- ✅ Works offline
- ✅ No external dependencies

### **Hybrid Benefits:**
- 🎯 **Best of both worlds** - semantic understanding + exact matching
- 📈 **Higher recall** - finds more relevant results
- 🎯 **Better precision** - ranks results more accurately
- 🔄 **Fallback support** - works even if semantic search fails
- ⚡ **Performance** - can cache semantic embeddings

## Implementation Approaches

### 1. **Client-Side Hybrid Search**

#### **Lunr.js + Embeddings**

```typescript
// src/lib/hybrid-search.ts
import lunr from 'lunr';
import { embedText } from './embeddings';

export interface SearchDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  section?: string;
  tags?: string[];
  embedding?: number[];
}

export interface SearchResult {
  document: SearchDocument;
  literalScore: number;
  semanticScore: number;
  combinedScore: number;
  matchType: 'literal' | 'semantic' | 'hybrid';
}

export class HybridSearch {
  private literalIndex: lunr.Index;
  private documents: SearchDocument[];
  private embeddings: Map<string, number[]>;

  constructor(documents: SearchDocument[]) {
    this.documents = documents;
    this.embeddings = new Map();
    
    // Build literal search index
    this.literalIndex = lunr(function() {
      this.ref('id');
      this.field('title', { boost: 10 });
      this.field('content', { boost: 5 });
      this.field('section', { boost: 3 });
      this.field('tags', { boost: 2 });

      documents.forEach(doc => {
        this.add(doc);
      });
    });
  }

  async initializeEmbeddings() {
    // Generate embeddings for all documents
    for (const doc of this.documents) {
      const text = `${doc.title} ${doc.content}`;
      const embedding = await embedText(text);
      this.embeddings.set(doc.id, embedding);
    }
  }

  async search(query: string, limit = 10): Promise<SearchResult[]> {
    const results: SearchResult[] = [];

    // 1. Literal search
    const literalResults = this.literalIndex.search(query);
    const literalScores = new Map<string, number>();
    
    literalResults.forEach(result => {
      literalScores.set(result.ref, result.score || 0);
    });

    // 2. Semantic search
    const queryEmbedding = await embedText(query);
    const semanticScores = new Map<string, number>();
    
    for (const [docId, docEmbedding] of this.embeddings) {
      const similarity = this.cosineSimilarity(queryEmbedding, docEmbedding);
      semanticScores.set(docId, similarity);
    }

    // 3. Combine results
    const allDocIds = new Set([
      ...literalScores.keys(),
      ...semanticScores.keys()
    ]);

    for (const docId of allDocIds) {
      const document = this.documents.find(d => d.id === docId);
      if (!document) continue;

      const literalScore = literalScores.get(docId) || 0;
      const semanticScore = semanticScores.get(docId) || 0;
      
      // Determine match type
      let matchType: 'literal' | 'semantic' | 'hybrid';
      if (literalScore > 0 && semanticScore > 0.3) {
        matchType = 'hybrid';
      } else if (literalScore > 0) {
        matchType = 'literal';
      } else {
        matchType = 'semantic';
      }

      // Combine scores (weighted average)
      const combinedScore = this.combineScores(literalScore, semanticScore);

      results.push({
        document,
        literalScore,
        semanticScore,
        combinedScore,
        matchType
      });
    }

    // Sort by combined score and limit
    return results
      .sort((a, b) => b.combinedScore - a.combinedScore)
      .slice(0, limit);
  }

  private cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  private combineScores(literalScore: number, semanticScore: number): number {
    // Normalize scores to 0-1 range
    const normalizedLiteral = Math.min(literalScore / 10, 1);
    const normalizedSemantic = semanticScore;
    
    // Weighted combination (adjust weights based on preference)
    const literalWeight = 0.6;
    const semanticWeight = 0.4;
    
    return (normalizedLiteral * literalWeight) + (normalizedSemantic * semanticWeight);
  }
}
```

#### **Embeddings Implementation**

```typescript
// src/lib/embeddings.ts
import { pipeline } from '@xenova/transformers';

let embedder: any = null;

export async function embedText(text: string): Promise<number[]> {
  if (!embedder) {
    // Load the embedding model (runs in browser)
    embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  }
  
  const result = await embedder(text, { pooling: 'mean', normalize: true });
  return Array.from(result.data);
}

// Alternative: Use a smaller model for better performance
export async function embedTextFast(text: string): Promise<number[]> {
  if (!embedder) {
    embedder = await pipeline('feature-extraction', 'Xenova/paraphrase-MiniLM-L3-v2');
  }
  
  const result = await embedder(text, { pooling: 'mean', normalize: true });
  return Array.from(result.data);
}
```

### 2. **Build-Time Hybrid Search**

#### **Pre-computed Embeddings**

```typescript
// scripts/build-hybrid-search.ts
import { buildPages } from 'svelte-markdown-pages/builder';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { embedText } from './embeddings';

export interface HybridSearchDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  section?: string;
  tags?: string[];
  embedding: number[];
  keywords: string[];
}

export async function buildHybridSearchIndex(contentPath: string): Promise<{
  documents: HybridSearchDocument[];
  literalIndex: any;
}> {
  const result = await buildPages(contentPath, {
    includeContent: true
  });
  
  const documents: HybridSearchDocument[] = [];
  
  function processItems(items: any[], parentPath = '') {
    for (const item of items) {
      if (item.type === 'page' && item.path) {
        const content = result.content?.[item.path];
        if (content) {
          const title = extractTitle(content);
          const tags = extractTags(content);
          const cleanContent = cleanContent(content);
          const keywords = extractKeywords(cleanContent);
          
          // Generate embedding
          const text = `${title} ${cleanContent}`;
          const embedding = await embedText(text);
          
          documents.push({
            id: item.path,
            title,
            content: cleanContent,
            url: `/${item.path.replace(/\.md$/, '')}`,
            section: parentPath || undefined,
            tags: tags.length > 0 ? tags : undefined,
            embedding,
            keywords
          });
        }
      } else if (item.items) {
        const sectionPath = parentPath ? `${parentPath} > ${item.label}` : item.label;
        processItems(item.items, sectionPath);
      }
    }
  }
  
  await processItems(result.navigation.items);
  
  // Build literal search index
  const literalIndex = buildLiteralIndex(documents);
  
  return { documents, literalIndex };
}

function extractKeywords(content: string): string[] {
  // Extract important keywords from content
  const words = content.toLowerCase()
    .replace(/[^\w\s]/g, '')
    .split(/\s+/)
    .filter(word => word.length > 3);
  
  // Count frequency
  const frequency: Record<string, number> = {};
  words.forEach(word => {
    frequency[word] = (frequency[word] || 0) + 1;
  });
  
  // Return top keywords
  return Object.entries(frequency)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 20)
    .map(([word]) => word);
}

function buildLiteralIndex(documents: HybridSearchDocument[]) {
  // Build a lightweight literal search index
  const index: Record<string, any> = {};
  
  documents.forEach(doc => {
    const terms = [
      ...doc.title.toLowerCase().split(/\s+/),
      ...doc.content.toLowerCase().split(/\s+/),
      ...(doc.keywords || [])
    ];
    
    terms.forEach(term => {
      if (!index[term]) {
        index[term] = [];
      }
      if (!index[term].includes(doc.id)) {
        index[term].push(doc.id);
      }
    });
  });
  
  return index;
}
```

### 3. **Svelte Component with Hybrid Search**

```svelte
<!-- src/lib/components/HybridSearch.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { HybridSearch, type SearchResult } from '$lib/hybrid-search';
  
  export let documents: any[] = [];
  export let placeholder = 'Search with semantic understanding...';
  export let maxResults = 10;
  export let showMatchType = true;
  
  let searchQuery = '';
  let searchResults: SearchResult[] = [];
  let searchInstance: HybridSearch;
  let isSearching = false;
  let showResults = false;
  let searchMode: 'hybrid' | 'literal' | 'semantic' = 'hybrid';
  
  const dispatch = createEventDispatcher();
  
  // Initialize search
  $: {
    if (documents.length > 0 && !searchInstance) {
      searchInstance = new HybridSearch(documents);
      searchInstance.initializeEmbeddings();
    }
  }
  
  // Perform search with debouncing
  let searchTimeout: number;
  $: {
    if (searchInstance && searchQuery.trim()) {
      clearTimeout(searchTimeout);
      isSearching = true;
      showResults = true;
      
      searchTimeout = setTimeout(async () => {
        try {
          searchResults = await searchInstance.search(searchQuery, maxResults);
        } catch (error) {
          console.error('Search error:', error);
          searchResults = [];
        }
        isSearching = false;
      }, 300);
    } else {
      searchResults = [];
      showResults = false;
    }
  }
  
  function handleResultClick(result: SearchResult) {
    dispatch('resultClick', result);
    showResults = false;
    searchQuery = '';
  }
  
  function getMatchTypeIcon(matchType: string): string {
    switch (matchType) {
      case 'hybrid': return '🔗';
      case 'literal': return '📝';
      case 'semantic': return '🧠';
      default: return '🔍';
    }
  }
  
  function getMatchTypeLabel(matchType: string): string {
    switch (matchType) {
      case 'hybrid': return 'Hybrid Match';
      case 'literal': return 'Exact Match';
      case 'semantic': return 'Semantic Match';
      default: return 'Match';
    }
  }
</script>

<div class="hybrid-search-container">
  <div class="search-controls">
    <div class="search-input-wrapper">
      <input
        type="text"
        bind:value={searchQuery}
        {placeholder}
        class="search-input"
        aria-label="Search documentation"
      />
      {#if isSearching}
        <div class="search-spinner">🔍</div>
      {/if}
    </div>
    
    <div class="search-mode-selector">
      <label>
        <input 
          type="radio" 
          bind:group={searchMode} 
          value="hybrid"
        />
        Hybrid
      </label>
      <label>
        <input 
          type="radio" 
          bind:group={searchMode} 
          value="literal"
        />
        Literal
      </label>
      <label>
        <input 
          type="radio" 
          bind:group={searchMode} 
          value="semantic"
        />
        Semantic
      </label>
    </div>
  </div>
  
  {#if showResults && searchResults.length > 0}
    <div class="search-results" role="listbox">
      {#each searchResults as result (result.document.id)}
        <div 
          class="search-result"
          on:click={() => handleResultClick(result)}
          role="option"
          tabindex="0"
          on:keydown={(e) => e.key === 'Enter' && handleResultClick(result)}
        >
          <div class="result-header">
            <h4 class="result-title">{result.document.title}</h4>
            {#if showMatchType}
              <span class="match-type" title={getMatchTypeLabel(result.matchType)}>
                {getMatchTypeIcon(result.matchType)}
              </span>
            {/if}
            {#if result.document.section}
              <span class="result-section">{result.document.section}</span>
            {/if}
          </div>
          
          <p class="result-excerpt">
            {result.document.content.substring(0, 150)}
            {result.document.content.length > 150 ? '...' : ''}
          </p>
          
          <div class="result-scores">
            <span class="score literal-score">
              Literal: {(result.literalScore * 100).toFixed(1)}%
            </span>
            <span class="score semantic-score">
              Semantic: {(result.semanticScore * 100).toFixed(1)}%
            </span>
            <span class="score combined-score">
              Combined: {(result.combinedScore * 100).toFixed(1)}%
            </span>
          </div>
          
          {#if result.document.tags && result.document.tags.length > 0}
            <div class="result-tags">
              {#each result.document.tags as tag}
                <span class="tag">{tag}</span>
              {/each}
            </div>
          {/if}
        </div>
      {/each}
    </div>
  {:else if showResults && searchQuery.trim() && !isSearching}
    <div class="no-results">
      <p>No results found for "{searchQuery}"</p>
      <p class="no-results-suggestions">
        Try different keywords or rephrase your query
      </p>
    </div>
  {/if}
</div>

<style>
  .hybrid-search-container {
    position: relative;
    width: 100%;
    max-width: 700px;
    margin: 0 auto;
  }
  
  .search-controls {
    display: flex;
    gap: 16px;
    align-items: center;
    margin-bottom: 8px;
  }
  
  .search-input-wrapper {
    position: relative;
    flex: 1;
  }
  
  .search-input {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.2s;
  }
  
  .search-input:focus {
    outline: none;
    border-color: #3b82f6;
  }
  
  .search-mode-selector {
    display: flex;
    gap: 12px;
    font-size: 14px;
  }
  
  .search-mode-selector label {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
  }
  
  .search-spinner {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: translateY(-50%) rotate(0deg); }
    to { transform: translateY(-50%) rotate(360deg); }
  }
  
  .search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    max-height: 600px;
    overflow-y: auto;
    z-index: 1000;
    margin-top: 4px;
  }
  
  .search-result {
    padding: 16px;
    border-bottom: 1px solid #f1f5f9;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  
  .search-result:hover,
  .search-result:focus {
    background: #f8fafc;
    outline: none;
  }
  
  .result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .result-title {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #1e293b;
    flex: 1;
  }
  
  .match-type {
    font-size: 16px;
    cursor: help;
  }
  
  .result-section {
    font-size: 12px;
    color: #64748b;
    background: #f1f5f9;
    padding: 2px 8px;
    border-radius: 12px;
    white-space: nowrap;
  }
  
  .result-excerpt {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #475569;
    line-height: 1.5;
  }
  
  .result-scores {
    display: flex;
    gap: 12px;
    margin-bottom: 8px;
    font-size: 12px;
  }
  
  .score {
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: 500;
  }
  
  .literal-score {
    background: #eff6ff;
    color: #1d4ed8;
  }
  
  .semantic-score {
    background: #fef3c7;
    color: #d97706;
  }
  
  .combined-score {
    background: #dcfce7;
    color: #16a34a;
  }
  
  .result-tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }
  
  .tag {
    font-size: 11px;
    color: #3b82f6;
    background: #eff6ff;
    padding: 2px 6px;
    border-radius: 4px;
  }
  
  .no-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    padding: 24px;
    text-align: center;
    margin-top: 4px;
    z-index: 1000;
  }
  
  .no-results p {
    margin: 0 0 8px 0;
    color: #64748b;
  }
  
  .no-results-suggestions {
    font-size: 14px;
    color: #94a3b8;
  }
</style>
```

## Performance Optimization

### 1. **Embedding Caching**

```typescript
// Cache embeddings in localStorage or IndexedDB
export class EmbeddingCache {
  private cache: Map<string, number[]> = new Map();
  
  async getEmbedding(text: string): Promise<number[]> {
    const hash = this.hashText(text);
    
    if (this.cache.has(hash)) {
      return this.cache.get(hash)!;
    }
    
    const embedding = await embedText(text);
    this.cache.set(hash, embedding);
    return embedding;
  }
  
  private hashText(text: string): string {
    // Simple hash function
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString();
  }
}
```

### 2. **Progressive Loading**

```typescript
// Load semantic search progressively
export class ProgressiveHybridSearch {
  private literalResults: SearchResult[] = [];
  private semanticResults: SearchResult[] = [];
  
  async search(query: string, limit = 10): Promise<SearchResult[]> {
    // 1. Show literal results immediately
    this.literalResults = this.performLiteralSearch(query, limit);
    
    // 2. Load semantic results in background
    setTimeout(async () => {
      this.semanticResults = await this.performSemanticSearch(query, limit);
      this.combineResults();
    }, 100);
    
    return this.literalResults;
  }
}
```

### 3. **Web Workers**

```typescript
// Move heavy computation to web worker
// search-worker.js
import { embedText } from './embeddings';

self.onmessage = async function(e) {
  const { type, query, documents } = e.data;
  
  if (type === 'semantic-search') {
    const queryEmbedding = await embedText(query);
    const results = [];
    
    for (const doc of documents) {
      const similarity = cosineSimilarity(queryEmbedding, doc.embedding);
      results.push({ id: doc.id, score: similarity });
    }
    
    self.postMessage({ type: 'semantic-results', results });
  }
};
```

## Comparison with Pure Solutions

| Aspect | Pure Literal | Pure Semantic | Hybrid |
|--------|--------------|---------------|---------|
| **Accuracy** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Speed** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **Offline** | ✅ | ❌ | ✅ |
| **Bundle Size** | Small | Large | Medium |
| **Complexity** | Low | High | Medium |
| **Fallback** | N/A | N/A | ✅ |

## Implementation Checklist

- [ ] Choose embedding model (client-side vs build-time)
- [ ] Implement literal search index
- [ ] Set up semantic search with embeddings
- [ ] Create result fusion algorithm
- [ ] Build hybrid search component
- [ ] Add performance optimizations
- [ ] Test with various query types
- [ ] Optimize bundle size
- [ ] Add fallback mechanisms

## Recommendations

### **Use Hybrid Search When:**
- You want the best possible search accuracy
- You have diverse content types
- Users expect both exact and conceptual matches
- You can afford the additional complexity

### **Stick with Literal Search When:**
- Performance is critical
- Bundle size is a concern
- Content is mostly technical/structured
- You need offline functionality

### **Use Pure Semantic Search When:**
- Content is highly conceptual
- Users write natural language queries
- You have server-side processing available

Hybrid search provides the best user experience by combining the strengths of both approaches while maintaining reasonable performance and bundle size!
---

# From docs/proposals/plugins.md:

# Plugin System Proposal

A proposal for extending svelte-markdown-pages functionality with a plugin system for custom processing, styling, and features.

## Overview

This proposal outlines a plugin system that would allow users to extend the functionality of svelte-markdown-pages with custom processors, transformers, and utilities. The system would be designed to integrate seamlessly with the existing architecture while providing flexibility for advanced use cases.

## Current Architecture

The current implementation already supports basic content processing through the `ContentProcessor` interface:

```typescript
interface ContentProcessor {
  process(content: string): string;
}
```

This is used in the `buildPages` and `generateStaticSite` functions to transform markdown content before it's converted to HTML.

## Proposed Plugin System

### Plugin Interface

```typescript
interface Plugin {
  name: string;
  version: string;
  description?: string;
  
  // Content processing
  process?: (content: string, context: PluginContext) => string;
  
  // Build lifecycle hooks
  beforeBuild?: (context: BuildContext) => void | Promise<void>;
  afterBuild?: (result: BuildResult, context: BuildContext) => void | Promise<void>;
  
  // Validation
  validate?: (content: string, context: PluginContext) => boolean | ValidationResult;
  
  // Configuration
  configure?: (options: Record<string, any>) => void;
}

interface PluginContext {
  filePath: string;
  fileName: string;
  navigation: NavigationTree;
  options: BuildOptions;
}

interface BuildContext {
  contentPath: string;
  options: BuildOptions;
  navigation: NavigationTree;
}

interface ValidationResult {
  valid: boolean;
  errors?: string[];
  warnings?: string[];
}
```

### Enhanced BuildOptions

```typescript
interface BuildOptions {
  appOutput?: string;
  websiteOutput?: string;
  staticOutput?: string;
  includeContent?: boolean;
  
  // Plugin system
  plugins?: Plugin[];
  pluginOptions?: Record<string, any>;
}
```

## Plugin Categories

### 1. Content Processors

Plugins that transform markdown content before HTML conversion:

```typescript
const admonitionPlugin: Plugin = {
  name: 'admonition',
  version: '1.0.0',
  description: 'Adds support for admonition blocks',
  
  process(content: string, context: PluginContext): string {
    return content.replace(
      /^:::(\w+)\n([\s\S]*?)\n:::$/gm,
      (match, type, content) => {
        const icons = {
          info: 'ℹ️',
          warning: '⚠️',
          error: '❌',
          success: '✅'
        };
        
        return `
          <div class="admonition admonition-${type}">
            <div class="admonition-header">
              ${icons[type] || '📝'} ${type.charAt(0).toUpperCase() + type.slice(1)}
            </div>
            <div class="admonition-content">
              ${content}
            </div>
          </div>
        `;
      }
    );
  }
};
```

### 2. Build Hooks

Plugins that run at specific points in the build process:

```typescript
const analyticsPlugin: Plugin = {
  name: 'analytics',
  version: '1.0.0',
  description: 'Adds analytics tracking to generated pages',
  
  beforeBuild(context: BuildContext): void {
    console.log(`Starting build for ${context.contentPath} with ${context.navigation.items.length} root items`);
  },
  
  afterBuild(result: BuildResult, context: BuildContext): void {
    console.log(`Build completed: ${result.content ? Object.keys(result.content).length : 0} pages processed`);
  }
};
```

### 3. Validators

Plugins that validate content structure and quality:

```typescript
const linkValidatorPlugin: Plugin = {
  name: 'link-validator',
  version: '1.0.0',
  description: 'Validates internal and external links',
  
  validate(content: string, context: PluginContext): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // Check for broken internal links
    const internalLinks = content.match(/\[([^\]]+)\]\(([^)]+)\)/g) || [];
    for (const link of internalLinks) {
      const match = link.match(/\[([^\]]+)\]\(([^)]+)\)/);
      if (match && match[2].startsWith('./') && !match[2].includes('#')) {
        // Validate internal link exists
        // Implementation would check against navigation tree
      }
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
};
```

## Implementation Strategy

### Phase 1: Basic Plugin Support

1. **Extend BuildOptions interface** to include plugins array
2. **Modify buildPages function** to accept and process plugins
3. **Add plugin context** to provide metadata during processing
4. **Implement basic plugin lifecycle** (beforeBuild, process, afterBuild)

### Phase 2: Advanced Features

1. **Plugin configuration system** for options and settings
2. **Plugin validation** and error handling
3. **Plugin dependencies** and ordering
4. **Plugin registry** for discovery and installation

### Phase 3: Ecosystem

1. **Built-in plugins** for common use cases
2. **Plugin documentation** and examples
3. **Plugin testing utilities**
4. **Plugin marketplace** or registry

## Built-in Plugins

### Syntax Highlighting

```typescript
const syntaxHighlightingPlugin: Plugin = {
  name: 'syntax-highlighting',
  version: '1.0.0',
  description: 'Adds syntax highlighting to code blocks',
  
  process(content: string): string {
    return content.replace(
      /```(\w+)\n([\s\S]*?)```/g,
      (match, lang, code) => {
        return `<pre><code class="language-${lang}">${code}</code></pre>`;
      }
    );
  }
};
```

### Table of Contents

```typescript
const tocPlugin: Plugin = {
  name: 'table-of-contents',
  version: '1.0.0',
  description: 'Automatically generates table of contents',
  
  process(content: string): string {
    const headings = content.match(/^(#{1,6})\s+(.+)$/gm) || [];
    if (headings.length === 0) return content;
    
    const toc = headings.map(heading => {
      const match = heading.match(/^(#{1,6})\s+(.+)$/);
      if (!match) return '';
      
      const level = match[1].length;
      const text = match[2];
      const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-');
      
      return `${'  '.repeat(level - 1)}- [${text}](#${id})`;
    }).join('\n');
    
    return `## Table of Contents\n\n${toc}\n\n${content}`;
  }
};
```

## Plugin Configuration

### Global Configuration

```typescript
await buildPages('./docs', {
  appOutput: './src/lib/content',
  plugins: [admonitionPlugin, tocPlugin],
  pluginOptions: {
    'admonition': {
      icons: { custom: '🎯' },
      styles: { theme: 'dark' }
    },
    'toc': {
      minDepth: 2,
      maxDepth: 4
    }
  }
});
```

### Plugin-Specific Configuration

```typescript
const configurablePlugin: Plugin = {
  name: 'configurable',
  version: '1.0.0',
  
  private config: Record<string, any> = {};
  
  configure(options: Record<string, any>): void {
    this.config = { ...this.config, ...options };
  },
  
  process(content: string): string {
    if (this.config.enabled === false) {
      return content;
    }
    
    // Use configuration in processing
    return content;
  }
};
```

## Plugin Development

### Plugin Structure

```
my-plugin/
├── package.json
├── src/
│   ├── index.ts
│   └── plugin.ts
├── tests/
│   └── plugin.test.ts
└── README.md
```

### Plugin Package.json

```json
{
  "name": "svelte-markdown-pages-my-plugin",
  "version": "1.0.0",
  "description": "My custom plugin for svelte-markdown-pages",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "keywords": ["svelte-markdown-pages", "plugin"],
  "peerDependencies": {
    "svelte-markdown-pages": "^1.0.0"
  },
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  }
}
```

### Plugin Testing

```typescript
import { describe, it, expect } from 'vitest';
import { myPlugin } from './plugin';

describe('My Plugin', () => {
  it('should process content correctly', () => {
    const input = 'Test content';
    const expected = 'Processed test content';
    
    const result = myPlugin.process?.(input, {
      filePath: 'test.md',
      fileName: 'test.md',
      navigation: { items: [] },
      options: {}
    });
    
    expect(result).toBe(expected);
  });
});
```

## Migration Path

### For Existing Users

The plugin system would be backward compatible:

```typescript
// Current usage continues to work
await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true
});

// New plugin usage
await buildPages('./docs', {
  appOutput: './src/lib/content',
  includeContent: true,
  plugins: [myPlugin]
});
```

### For ContentProcessor Users

Existing `ContentProcessor` implementations could be wrapped as plugins:

```typescript
const legacyProcessor: ContentProcessor = {
  process(content: string): string {
    return content.replace(/pattern/g, 'replacement');
  }
};

const legacyPlugin: Plugin = {
  name: 'legacy-processor',
  version: '1.0.0',
  process: legacyProcessor.process
};
```

## Benefits

1. **Extensibility**: Users can add custom functionality without modifying core code
2. **Modularity**: Features can be developed and distributed independently
3. **Ecosystem**: Enables community contributions and plugin marketplace
4. **Flexibility**: Supports various use cases from simple processors to complex build tools
5. **Maintainability**: Keeps core functionality focused while allowing extensions

## Considerations

1. **Performance**: Plugin processing adds overhead to build time
2. **Complexity**: Plugin system increases API surface area
3. **Compatibility**: Need to maintain backward compatibility
4. **Security**: Plugins run with full access to build context
5. **Testing**: Plugin system needs comprehensive testing

## Next Steps

1. **Gather feedback** on the proposed interface and features
2. **Implement Phase 1** with basic plugin support
3. **Create example plugins** to validate the design
4. **Document plugin development** guidelines
5. **Establish plugin ecosystem** and distribution mechanisms

This proposal provides a foundation for a flexible and powerful plugin system while maintaining the simplicity and reliability of the current implementation.
---

# From docs/proposals/search-quick-reference.md:

# Search Solutions Quick Reference

Quick comparison and setup guide for the most popular search solutions for svelte-markdown-pages.

## Quick Comparison

| Solution | Setup Time | Cost | Performance | Features | Best For |
|----------|------------|------|-------------|----------|----------|
| **Algolia DocSearch** | ⭐⭐⭐ | Free (OSS) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Production sites |
| **Lunr.js** | ⭐⭐⭐⭐⭐ | Free | ⭐⭐⭐ | ⭐⭐ | Small sites |
| **Meilisearch** | ⭐⭐⭐ | Free | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | Self-hosted |
| **Typesense** | ⭐⭐⭐ | Free | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | Modern apps |

## 1. Algolia DocSearch (Recommended)

### Quick Setup
```bash
npm install @docsearch/react @docsearch/js
```

### Basic Implementation
```svelte
<script>
  import { onMount } from 'svelte';
  import '@docsearch/css';
  
  let searchContainer;
  
  onMount(() => {
    import('@docsearch/js').then(({ default: docsearch }) => {
      docsearch({
        appId: 'YOUR_APP_ID',
        apiKey: 'YOUR_API_KEY',
        indexName: 'your-index',
        container: searchContainer
      });
    });
  });
</script>

<div bind:this={searchContainer}></div>
```

### Pros
- ✅ Free for open source
- ✅ Excellent relevance
- ✅ Built-in analytics
- ✅ Typo tolerance

### Cons
- ❌ Application process required
- ❌ Limited customization (free tier)

## 2. Lunr.js (Client-Side)

### Quick Setup
```bash
npm install lunr
```

### Basic Implementation
```typescript
import lunr from 'lunr';

const idx = lunr(function() {
  this.ref('id');
  this.field('title', { boost: 10 });
  this.field('content');
  
  documents.forEach(doc => this.add(doc));
});

const results = idx.search('query');
```

### Pros
- ✅ No server required
- ✅ Full control
- ✅ Fast for small datasets
- ✅ Zero cost

### Cons
- ❌ Limited to client-side
- ❌ Not suitable for large datasets
- ❌ Basic semantic capabilities

## 3. Meilisearch (Self-Hosted)

### Quick Setup
```bash
# Install Meilisearch
curl -L https://install.meilisearch.com | sh

# Start server
./meilisearch --master-key=your-master-key

# Install client
npm install meilisearch-instant-meilisearch
```

### Basic Implementation
```svelte
<script>
  import { onMount } from 'svelte';
  import { instantMeiliSearch } from 'meilisearch-instant-meilisearch';
  
  let searchContainer;
  
  onMount(() => {
    const { instantSearch } = instantMeiliSearch(
      'http://localhost:7700',
      'your-search-key'
    );
    instantSearch.mount(searchContainer);
  });
</script>

<div bind:this={searchContainer}></div>
```

### Pros
- ✅ Open source
- ✅ Excellent performance
- ✅ Full control
- ✅ Typo tolerance

### Cons
- ❌ Requires server setup
- ❌ More maintenance

## 4. Typesense (Modern Alternative)

### Quick Setup
```bash
# Install Typesense
docker run -p 8108:8108 typesense/typesense:latest

# Install client
npm install typesense-instantsearch-adapter
```

### Basic Implementation
```svelte
<script>
  import { onMount } from 'svelte';
  import TypesenseInstantSearchAdapter from 'typesense-instantsearch-adapter';
  
  let searchContainer;
  
  onMount(() => {
    const adapter = new TypesenseInstantSearchAdapter({
      server: {
        apiKey: 'your-api-key',
        nodes: [{ host: 'localhost', port: '8108', protocol: 'http' }]
      }
    });
    
    const search = instantsearch({
      searchClient: adapter.searchClient,
      indexName: 'docs'
    });
    
    search.addWidgets([
      instantsearch.widgets.searchBox({ container: searchContainer })
    ]);
    
    search.start();
  });
</script>

<div bind:this={searchContainer}></div>
```

### Pros
- ✅ Open source
- ✅ Excellent performance
- ✅ Real-time updates
- ✅ Built-in analytics

### Cons
- ❌ Requires server setup
- ❌ Smaller community

## Integration with svelte-markdown-pages

### Content Extraction
```typescript
import { buildPages } from 'svelte-markdown-pages/builder';

async function extractSearchContent(contentPath: string) {
  const result = await buildPages(contentPath, { includeContent: true });
  
  return Object.entries(result.content || {}).map(([path, content]) => ({
    id: path,
    title: extractTitle(content),
    content: cleanContent(content),
    url: `/${path.replace(/\.md$/, '')}`
  }));
}
```

### Build Integration
```json
{
  "scripts": {
    "build:search": "node scripts/build-search-index.js",
    "build": "npm run build:docs && npm run build:search"
  }
}
```

## Quick Decision Guide

### Choose Algolia DocSearch if:
- You have a production site
- You want the best search experience
- You're okay with the application process
- You want analytics and insights

### Choose Lunr.js if:
- You have a small site (< 100 pages)
- You want zero external dependencies
- You want full control over search
- You want to keep everything client-side

### Choose Meilisearch if:
- You want self-hosted control
- You have technical expertise
- You want excellent performance
- You want to avoid vendor lock-in

### Choose Typesense if:
- You want modern features
- You need real-time updates
- You want built-in analytics
- You're comfortable with server setup

## Getting Started Checklist

1. **Choose your solution** based on requirements
2. **Install dependencies** for your chosen solution
3. **Set up search service** (if required)
4. **Extract content** from your markdown files
5. **Create search index** with your content
6. **Implement search UI** component
7. **Integrate with layout** and navigation
8. **Test and optimize** search functionality

## Resources

- [Algolia DocSearch](https://docsearch.algolia.com/)
- [Lunr.js Documentation](https://lunrjs.com/)
- [Meilisearch Documentation](https://docs.meilisearch.com/)
- [Typesense Documentation](https://typesense.org/docs/)
- [svelte-markdown-pages Documentation](../README.md)
---

# From docs/proposals/search.md:

# Semantic Search Implementation Guide

A guide for adding semantic search functionality to svelte-markdown-pages websites using various solutions.

## Overview

Semantic search allows users to find content using natural language queries, understanding context and meaning rather than just keyword matching. This guide covers several approaches to implement search in svelte-markdown-pages websites.

## Search Solutions

### 1. **Algolia DocSearch** (Recommended for Production)

**Best for**: Large documentation sites, production applications
**Pros**: 
- Free for open source projects
- Excellent relevance and typo tolerance
- Built-in analytics and insights
- Easy integration with SvelteKit
- Handles large datasets efficiently

**Cons**: 
- Requires application process for free tier
- Limited customization on free plan

#### Implementation

```bash
npm install @docsearch/react @docsearch/js
```

```svelte
<!-- src/lib/components/Search.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import '@docsearch/css';

  let searchContainer: HTMLElement;

  onMount(() => {
    import('@docsearch/js').then(({ default: docsearch }) => {
      docsearch({
        appId: 'YOUR_APP_ID',
        apiKey: 'YOUR_API_KEY',
        indexName: 'your-index-name',
        container: searchContainer,
        placeholder: 'Search documentation...',
        searchParameters: {
          facetFilters: ['type:content']
        }
      });
    });
  });
</script>

<div class="search-wrapper">
  <div bind:this={searchContainer}></div>
</div>

<style>
  .search-wrapper {
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
  }
</style>
```

#### Setup Process
1. Apply for DocSearch at https://docsearch.algolia.com/
2. Configure your site structure
3. Algolia will crawl your site and create search index
4. Receive API credentials and integrate

### 2. **Meilisearch** (Self-Hosted Alternative)

**Best for**: Self-hosted solutions, full control
**Pros**: 
- Open source and self-hosted
- Excellent performance
- Full control over data and configuration
- Typo tolerance and relevance
- RESTful API

**Cons**: 
- Requires server infrastructure
- More setup and maintenance

#### Implementation

```bash
npm install meilisearch-instant-meilisearch
```

```svelte
<!-- src/lib/components/MeiliSearch.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { instantMeiliSearch } from 'meilisearch-instant-meilisearch';

  let searchContainer: HTMLElement;
  let searchClient: any;

  onMount(() => {
    const { searchClient: client, instantSearch } = instantMeiliSearch(
      'http://localhost:7700',
      'your-search-key'
    );
    
    searchClient = client;
    instantSearch.mount(searchContainer);
  });
</script>

<div class="search-wrapper">
  <div bind:this={searchContainer}></div>
</div>
```

#### Setup Process
1. Install Meilisearch server
2. Create search index
3. Index your content
4. Configure search parameters

### 3. **Typesense** (Modern Alternative)

**Best for**: Modern applications, real-time search
**Pros**: 
- Open source
- Excellent performance
- Built-in analytics
- Real-time updates
- Good documentation

**Cons**: 
- Requires server setup
- Smaller community than Algolia

#### Implementation

```bash
npm install typesense-instantsearch-adapter
```

```svelte
<!-- src/lib/components/TypesenseSearch.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import TypesenseInstantSearchAdapter from 'typesense-instantsearch-adapter';

  let searchContainer: HTMLElement;

  onMount(() => {
    const typesenseInstantsearchAdapter = new TypesenseInstantSearchAdapter({
      server: {
        apiKey: 'your-api-key',
        nodes: [{
          host: 'localhost',
          port: '8108',
          protocol: 'http'
        }]
      },
      additionalSearchParameters: {
        queryBy: 'title,content',
        sortBy: 'relevance_score:desc'
      }
    });

    const search = instantsearch({
      searchClient: typesenseInstantsearchAdapter.searchClient,
      indexName: 'docs'
    });

    search.addWidgets([
      instantsearch.widgets.searchBox({
        container: searchContainer,
        placeholder: 'Search documentation...'
      })
    ]);

    search.start();
  });
</script>

<div class="search-wrapper">
  <div bind:this={searchContainer}></div>
</div>
```

### 4. **Local Search with Lunr.js** (Client-Side)

**Best for**: Small to medium sites, no server required
**Pros**: 
- No server required
- Works entirely in browser
- Fast for small datasets
- Full control over search logic

**Cons**: 
- Limited to client-side processing
- Not suitable for large datasets
- Basic semantic capabilities

#### Implementation

```bash
npm install lunr
```

```typescript
// src/lib/search.ts
import lunr from 'lunr';

export interface SearchDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  section?: string;
}

export class LocalSearch {
  private index: lunr.Index;
  private documents: SearchDocument[];

  constructor(documents: SearchDocument[]) {
    this.documents = documents;
    this.index = lunr(function() {
      this.ref('id');
      this.field('title', { boost: 10 });
      this.field('content');
      this.field('section');

      documents.forEach(doc => {
        this.add(doc);
      });
    });
  }

  search(query: string): SearchDocument[] {
    const results = this.index.search(query);
    return results.map(result => 
      this.documents.find(doc => doc.id === result.ref)!
    );
  }
}
```

```svelte
<!-- src/lib/components/LocalSearch.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { LocalSearch, type SearchDocument } from '$lib/search';
  
  export let documents: SearchDocument[] = [];
  
  let searchQuery = '';
  let searchResults: SearchDocument[] = [];
  let searchInstance: LocalSearch;
  let isSearching = false;
  
  const dispatch = createEventDispatcher();
  
  $: {
    if (documents.length > 0 && !searchInstance) {
      searchInstance = new LocalSearch(documents);
    }
  }
  
  $: {
    if (searchInstance && searchQuery.trim()) {
      isSearching = true;
      searchResults = searchInstance.search(searchQuery);
      isSearching = false;
    } else {
      searchResults = [];
    }
  }
  
  function handleResultClick(result: SearchDocument) {
    dispatch('resultClick', result);
  }
</script>

<div class="search-container">
  <input
    type="text"
    bind:value={searchQuery}
    placeholder="Search documentation..."
    class="search-input"
  />
  
  {#if isSearching}
    <div class="search-loading">Searching...</div>
  {:else if searchResults.length > 0}
    <div class="search-results">
      {#each searchResults as result}
        <div 
          class="search-result"
          on:click={() => handleResultClick(result)}
        >
          <h4>{result.title}</h4>
          {#if result.section}
            <span class="section">{result.section}</span>
          {/if}
          <p>{result.content.substring(0, 150)}...</p>
        </div>
      {/each}
    </div>
  {:else if searchQuery.trim()}
    <div class="no-results">No results found</div>
  {/if}
</div>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 600px;
  }
  
  .search-input {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    font-size: 16px;
  }
  
  .search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
  }
  
  .search-result {
    padding: 12px 16px;
    border-bottom: 1px solid #f1f5f9;
    cursor: pointer;
  }
  
  .search-result:hover {
    background: #f8fafc;
  }
  
  .search-result h4 {
    margin: 0 0 4px 0;
    font-size: 14px;
    font-weight: 600;
  }
  
  .section {
    font-size: 12px;
    color: #64748b;
    background: #f1f5f9;
    padding: 2px 6px;
    border-radius: 4px;
  }
  
  .search-result p {
    margin: 8px 0 0 0;
    font-size: 13px;
    color: #475569;
  }
</style>
```

### 5. **OpenSearch (AWS)** (Enterprise)

**Best for**: Enterprise applications, AWS ecosystem
**Pros**: 
- Fully managed service
- Excellent scalability
- Advanced analytics
- Integration with AWS services

**Cons**: 
- Requires AWS account
- More complex setup
- Cost for large datasets

## Integration with svelte-markdown-pages

### Content Indexing

To make your content searchable, you'll need to extract and index your markdown content:

```typescript
// src/lib/search-index.ts
import { buildPages } from 'svelte-markdown-pages/builder';
import type { SearchDocument } from './search';

export async function buildSearchIndex(contentPath: string): Promise<SearchDocument[]> {
  const result = await buildPages(contentPath, {
    includeContent: true
  });
  
  const documents: SearchDocument[] = [];
  
  function processItems(items: any[], parentPath = '') {
    for (const item of items) {
      if (item.type === 'page' && item.path) {
        const content = result.content?.[item.path];
        if (content) {
          // Extract title from first heading
          const titleMatch = content.match(/^#\s+(.+)$/m);
          const title = titleMatch ? titleMatch[1] : item.label;
          
          // Clean content (remove markdown)
          const cleanContent = content
            .replace(/^#+\s+/gm, '') // Remove headings
            .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Remove links
            .replace(/`([^`]+)`/g, '$1') // Remove inline code
            .replace(/```[\s\S]*?```/g, '') // Remove code blocks
            .trim();
          
          documents.push({
            id: item.path,
            title,
            content: cleanContent,
            url: `/${item.path.replace(/\.md$/, '')}`,
            section: parentPath || undefined
          });
        }
      } else if (item.items) {
        const sectionPath = parentPath ? `${parentPath} > ${item.label}` : item.label;
        processItems(item.items, sectionPath);
      }
    }
  }
  
  processItems(result.navigation.items);
  return documents;
}
```

### Build Integration

Add search index generation to your build process:

```typescript
// scripts/build-with-search.js
import { buildSearchIndex } from '../src/lib/search-index.js';
import { writeFileSync } from 'fs';

async function buildWithSearch() {
  // Build documentation
  await buildPages('./docs', {
    appOutput: './src/lib/content',
    includeContent: true
  });
  
  // Build search index
  const searchDocuments = await buildSearchIndex('./docs');
  writeFileSync(
    './src/lib/search-index.json',
    JSON.stringify(searchDocuments, null, 2)
  );
}

buildWithSearch().catch(console.error);
```

### SvelteKit Integration

```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import Search from '$lib/components/Search.svelte';
  import searchIndex from '$lib/search-index.json';
</script>

<header>
  <Search {searchIndex} />
</header>

<main>
  <slot />
</main>
```

## Recommendations by Use Case

### **Small Documentation Site (< 100 pages)**
- **Recommendation**: Local Search with Lunr.js
- **Reason**: Simple setup, no external dependencies, fast performance

### **Medium Documentation Site (100-1000 pages)**
- **Recommendation**: Algolia DocSearch
- **Reason**: Excellent relevance, free for open source, easy integration

### **Large Documentation Site (> 1000 pages)**
- **Recommendation**: Meilisearch or Typesense
- **Reason**: Self-hosted control, excellent performance, cost-effective

### **Enterprise/Production Application**
- **Recommendation**: Algolia DocSearch or OpenSearch
- **Reason**: Managed service, enterprise features, reliability

### **Open Source Project**
- **Recommendation**: Algolia DocSearch
- **Reason**: Free tier available, excellent for community projects

## Implementation Checklist

- [ ] Choose search solution based on requirements
- [ ] Set up search service/engine
- [ ] Implement content indexing
- [ ] Create search UI component
- [ ] Integrate with svelte-markdown-pages build process
- [ ] Add search to layout/navigation
- [ ] Test search functionality
- [ ] Optimize search performance
- [ ] Add analytics and monitoring

## Performance Considerations

1. **Index Size**: Keep search index optimized for your use case
2. **Caching**: Cache search results when possible
3. **Debouncing**: Implement search debouncing for better UX
4. **Lazy Loading**: Load search results progressively
5. **CDN**: Use CDN for search assets when applicable

## Security Considerations

1. **API Keys**: Secure API keys and credentials
2. **Rate Limiting**: Implement rate limiting for search requests
3. **Input Validation**: Sanitize search queries
4. **Access Control**: Ensure search respects content permissions

This guide provides a comprehensive overview of implementing semantic search in svelte-markdown-pages websites, with specific recommendations based on different use cases and requirements.