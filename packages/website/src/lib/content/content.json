{
  "getting-started.md": "# Getting Started\n\nLet's get you set up with Markpage in just a few steps.\n\n> 📖 **This is the core getting started guide. For advanced features, see the [Custom Components](custom-components.md) and [Token Overrides](token-overrides.md) guides.**\n\n## What is Markpage?\n\nMarkpage helps you render Markdown files as HTML pages with any framework. It provides:\n\n- **Organized navigation structure** for your content\n- **Framework-agnostic** utilities that work with React, Vue, Svelte, Angular, or vanilla JavaScript\n- **Component system** for embedding interactive components in markdown (via `@markpage/svelte`)\n\n## Core Usage\n\n### 1. Install the Package\n\n```bash\nnpm install markpage\n```\n\n### 2. Create Your Content Structure\n\nCreate a directory with your markdown content:\n\n```\nmy-docs/\n├── getting-started.md\n├── installation.md\n└── guides/\n    ├── basic-usage.md\n    └── advanced-features.md\n```\n\n### 3. Build Your Documentation\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nawait buildPages('./my-docs', {\n  appOutput: './src/lib/content',\n  includeContent: true\n});\n```\n\n### 4. Use in Your App\n\n```typescript\nimport { NavigationTree, loadContent } from 'markpage/renderer';\nimport navigationData from './src/lib/content/navigation.json';\nimport contentBundle from './src/lib/content/content.json';\n\nconst navigation = new NavigationTree(navigationData);\nconst content = await loadContent('getting-started.md', contentBundle);\n```\n\n## Svelte Integration\n\nFor Svelte apps, use the `@markpage/svelte` package to render markdown with components:\n\n### 1. Install the Svelte Package\n\n```bash\nnpm install @markpage/svelte\n```\n\n### 2. Basic Markdown Rendering\n\n```svelte\n<script>\n  import { Markdown } from '@markpage/svelte';\n\n  const source = `\n# Hello World\n\nThis is **bold** text and this is *italic*.\n\n- List item 1\n- List item 2\n\n[Visit our website](https://example.com)\n  `;\n</script>\n\n<Markdown {source} />\n```\n\n### 3. With Custom Components\n\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import Button from './Button.svelte';\n\n  const options = new MarkpageOptions()\n    .addCustomComponent('Button', Button);\n\n  const source = `\n# My Documentation\n\nHere's a regular paragraph.\n\n<Button variant=\"primary\">Click me</Button>\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n## Navigation Structure\n\n### Automatic Discovery\n\nBy default, Markpage automatically discovers markdown files in alphabetical order:\n\n```\nmy-docs/\n├── getting-started.md    # 1st\n├── installation.md       # 2nd\n└── guides/\n    ├── basic-usage.md    # 3rd\n    └── advanced.md       # 4th\n```\n\n### Custom Navigation (Optional)\n\nCreate `.index.json` files to define custom navigation order:\n\n**Root level** (`my-docs/.index.json`):\n```json\n{\n  \"items\": [\n    { \"name\": \"getting-started\", \"type\": \"page\", \"label\": \"Getting Started\" },\n    { \"name\": \"guides\", \"type\": \"section\", \"label\": \"Guides\" }\n  ]\n}\n```\n\n**Section level** (`my-docs/guides/.index.json`):\n```json\n{\n  \"items\": [\n    { \"name\": \"basic-usage\", \"type\": \"page\", \"label\": \"Basic Usage\" },\n    { \"name\": \"advanced\", \"type\": \"page\", \"label\": \"Advanced Features\" }\n  ]\n}\n```\n\n## CLI Usage\n\n### Build for App/Website\n\n```bash\nnpx markpage build ./my-docs --output ./src/lib/content\n```\n\n## What's Next?\n\n- **[Custom Components](custom-components.md)** - Learn how to create and use custom components in markdown\n- **[Token Overrides](token-overrides.md)** - Override built-in markdown tokens and create extensions\n- **[Installation Guide](guides/installation.md)** - Detailed installation instructions\n",
  "custom-components.md": "# Custom Components\n\nLearn how to create and use custom Svelte components in your markdown files.\n\n## Overview\n\nWith `@markpage/svelte`, you can embed interactive Svelte components directly in markdown files. Components can contain markdown content and even other components.\n\n## Basic Usage\n\n### Register and Use Components\n\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import Button from './Button.svelte';\n  import Alert from './Alert.svelte';\n  import Card from './Card.svelte';\n  import TestButton from './TestButton.svelte';\n\n  const options = new MarkpageOptions()\n    .addCustomComponent('Button', Button)\n    .addCustomComponent('Alert', Alert)\n    .addCustomComponent('Card', Card)\n    .addCustomComponent('TestButton', TestButton);\n\n  const source = `\n# My Documentation\n\nHere's a regular paragraph.\n\n<Button variant=\"primary\">Click me</Button>\n<Alert variant=\"info\">This is an alert</Alert>\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n## Component Examples\n\n### Button Component\n\n**Markdown source:**\n```markdown\n<Button variant=\"primary\">Primary Button</Button>\n<Button variant=\"secondary\">Secondary Button</Button>\n<Button variant=\"danger\">Danger Button</Button>\n<Button variant=\"default\" disabled>Disabled Button</Button>\n\nDifferent sizes:\n<Button variant=\"primary\" size=\"small\">Small</Button>\n<Button variant=\"primary\" size=\"medium\">Medium</Button>\n<Button variant=\"primary\" size=\"large\">Large</Button>\n```\n\n**Rendered result:**\n<Button variant=\"primary\">Primary Button</Button>\n<Button variant=\"secondary\">Secondary Button</Button>\n<Button variant=\"danger\">Danger Button</Button>\n<Button variant=\"default\" disabled>Disabled Button</Button>\n\nDifferent sizes:\n<Button variant=\"primary\" size=\"small\">Small</Button>\n<Button variant=\"primary\" size=\"medium\">Medium</Button>\n<Button variant=\"primary\" size=\"large\">Large</Button>\n\n### Alert Component\n\n**Markdown source:**\n```markdown\n<Alert variant=\"info\">\n  This alert contains **markdown** content:\n  \n  - List items work\n  - **Bold text** works\n  - [Links](https://example.com) work too\n</Alert>\n\n<Alert variant=\"warning\">\n  This is a warning alert with an icon\n</Alert>\n\n<Alert variant=\"success\">\n  Success! Your operation completed successfully.\n</Alert>\n\n<Alert variant=\"error\">\n  Error! Something went wrong. Please try again.\n</Alert>\n```\n\n**Rendered result:**\n<Alert variant=\"info\">\n  This alert contains **markdown** content:\n  \n  - List items work\n  - **Bold text** works\n  - [Links](https://example.com) work too\n</Alert>\n\n<Alert variant=\"warning\">\n  This is a warning alert with an icon\n</Alert>\n\n<Alert variant=\"success\">\n  Success! Your operation completed successfully.\n</Alert>\n\n<Alert variant=\"error\">\n  Error! Something went wrong. Please try again.\n</Alert>\n\n### TestButton Component\n\n**Markdown source:**\n```markdown\n<TestButton text=\"Click me!\" variant=\"primary\" />\n<TestButton text=\"Success\" variant=\"success\" />\n<TestButton text=\"Warning\" variant=\"warning\" />\n<TestButton text=\"Danger\" variant=\"danger\" />\n```\n\n**Rendered result:**\n<TestButton text=\"Click me!\" variant=\"primary\" />\n<TestButton text=\"Success\" variant=\"success\" />\n<TestButton text=\"Warning\" variant=\"warning\" />\n<TestButton text=\"Danger\" variant=\"danger\" />\n\n### Card Component (Nested Components)\n\n**Markdown source:**\n```markdown\n<Card title=\"Nested Components\" subtitle=\"Components can contain other components\">\n  <Alert variant=\"info\">\n    This alert is **inside** a card component!\n  </Alert>\n  \n  <Button variant=\"primary\">Button in card</Button>\n  <TestButton text=\"Test Button\" variant=\"success\" />\n</Card>\n```\n\n**Rendered result:**\n<Card title=\"Nested Components\" subtitle=\"Components can contain other components\">\n  <Alert variant=\"info\">\n    This alert is **inside** a card component!\n  </Alert>\n  \n  <Button variant=\"primary\">Button in card</Button>\n  <TestButton text=\"Test Button\" variant=\"success\" />\n</Card>\n\n## What's Next?\n\n- **[Token Overrides](token-overrides.md)** - Override built-in markdown tokens and create extensions\n- **[Getting Started](getting-started.md)** - Back to the basics",
  "token-overrides.md": "# Token Overrides and Extensions\n\nLearn how to override built-in markdown tokens and create new markdown syntax with custom components.\n\n## Overview\n\nWith `@markpage/svelte`, you can:\n\n- **Override built-in tokens** (like `paragraph`, `heading`, `list`, etc.) with custom components\n- **Create new markdown syntax** with custom extensions (like LaTeX math, syntax highlighting, etc.)\n\n## Overriding Built-in Tokens\n\n### Basic Token Override\n\nOverride any built-in markdown token with a custom component:\n\n**CustomCodeSpan.svelte:**\n```svelte\n<script>\n  export let token;\n</script>\n\n<code class=\"custom-code\" data-overridden=\"true\">\n  {token.text}\n</code>\n\n<style>\n  .custom-code {\n    background: #f1f3f4;\n    padding: 2px 6px;\n    border-radius: 3px;\n    font-family: 'Monaco', 'Menlo', monospace;\n    font-size: 0.9em;\n    color: #d73a49;\n  }\n</style>\n```\n\n**Usage:**\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import CustomCodeSpan from './CustomCodeSpan.svelte';\n\n  const options = new MarkpageOptions()\n    .overrideBuiltinToken('codespan', CustomCodeSpan);\n\n  const source = `\nHere is some \\`inline code\\` with custom styling!\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n### Available Built-in Tokens\n\nYou can override any of these built-in tokens:\n\n- `heading` - Headers (# ## ###)\n- `paragraph` - Paragraphs\n- `list` - Lists\n- `list_item` - List items\n- `blockquote` - Blockquotes\n- `code` - Code blocks\n- `codespan` - Inline code\n- `link` - Links\n- `image` - Images\n- `strong` - Bold text\n- `em` - Italic text\n- `hr` - Horizontal rules\n- `table` - Tables\n- `table_row` - Table rows\n- `table_cell` - Table cells\n\n### Custom Heading Component\n\n**CustomHeading.svelte:**\n```svelte\n<script>\n  export let token;\n  \n  // Generate a unique ID for the heading\n  const id = token.text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '');\n</script>\n\n<h{token.depth} id={id} class=\"custom-heading\">\n  <a href=\"#{id}\" class=\"heading-link\">\n    {token.text}\n  </a>\n</h{token.depth}>\n\n<style>\n  .custom-heading {\n    position: relative;\n    margin: 2em 0 1em 0;\n    color: #2c3e50;\n  }\n  \n  .heading-link {\n    text-decoration: none;\n    color: inherit;\n  }\n  \n  .heading-link:hover::before {\n    content: '#';\n    position: absolute;\n    left: -1.5em;\n    color: #3498db;\n  }\n</style>\n```\n\n**Usage:**\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import CustomHeading from './CustomHeading.svelte';\n\n  const options = new MarkpageOptions()\n    .overrideBuiltinToken('heading', CustomHeading);\n\n  const source = `\n# Custom Heading with Link\n## Another Heading\n### Third Level Heading\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n## Creating Markdown Extensions\n\nExtensions let you add completely new markdown syntax with custom components.\n\n### LaTeX Math Extension\n\nCreate a math extension that supports both inline and block math:\n\n**MathInline.svelte:**\n```svelte\n<script>\n  export let token;\n</script>\n\n<span class=\"math-inline\" data-math=\"inline\">\n  {token.text}\n</span>\n\n<style>\n  .math-inline {\n    background: #f8f9fa;\n    padding: 2px 4px;\n    border-radius: 3px;\n    font-family: 'Times New Roman', serif;\n    font-style: italic;\n  }\n</style>\n```\n\n**MathBlock.svelte:**\n```svelte\n<script>\n  export let token;\n</script>\n\n<div class=\"math-block\" data-math=\"block\">\n  {token.text}\n</div>\n\n<style>\n  .math-block {\n    background: #f8f9fa;\n    padding: 16px;\n    border-radius: 8px;\n    margin: 16px 0;\n    text-align: center;\n    font-family: 'Times New Roman', serif;\n    font-size: 1.1em;\n  }\n</style>\n```\n\n**Extension Definition:**\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import MathInline from './MathInline.svelte';\n  import MathBlock from './MathBlock.svelte';\n\n  function mathExtension() {\n    return {\n      extensions: [\n        {\n          name: 'math_block',\n          level: 'block',\n          component: MathBlock,\n          start(src) {\n            const i = src.indexOf('$$');\n            return i < 0 ? undefined : i;\n          },\n          tokenizer(src) {\n            if (!src.startsWith('$$')) return;\n            const end = src.indexOf('$$', 2);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 2);\n            const text = src.slice(2, end).trim();\n            return { type: 'math_block', raw, text };\n          }\n        },\n        {\n          name: 'math_inline',\n          level: 'inline',\n          component: MathInline,\n          start(src) {\n            const i = src.indexOf('$');\n            return i < 0 ? undefined : i;\n          },\n          tokenizer(src) {\n            if (src.startsWith('$$')) return; // let block handle\n            if (!src.startsWith('$')) return;\n            const end = src.indexOf('$', 1);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 1);\n            const text = src.slice(1, end).trim();\n            return { type: 'math_inline', raw, text };\n          }\n        }\n      ]\n    };\n  }\n\n  const options = new MarkpageOptions()\n    .extendMarkdown(mathExtension());\n\n  const source = `\nHere is inline math: $E = mc^2$\n\nAnd here is a block equation:\n\n$$\n\\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} dx = \\\\sqrt{\\\\pi}\n$$\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n### Syntax Highlighting Extension\n\nCreate a syntax highlighting extension for code blocks:\n\n**SyntaxHighlightedCode.svelte:**\n```svelte\n<script>\n  export let token;\n  \n  // Simple syntax highlighting (you could integrate with a library like Prism.js)\n  function highlightCode(code, lang) {\n    if (!lang) return code;\n    \n    // Basic keyword highlighting\n    const keywords = {\n      javascript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'return'],\n      python: ['def', 'class', 'if', 'else', 'for', 'while', 'return', 'import', 'from'],\n      html: ['<', '>', '</', '/>']\n    };\n    \n    let highlighted = code;\n    if (keywords[lang]) {\n      keywords[lang].forEach(keyword => {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'g');\n        highlighted = highlighted.replace(regex, `<span class=\"keyword\">${keyword}</span>`);\n      });\n    }\n    \n    return highlighted;\n  }\n</script>\n\n<pre class=\"syntax-highlighted\"><code class=\"language-{token.lang || 'text'}\">{@html highlightCode(token.text, token.lang)}</code></pre>\n\n<style>\n  .syntax-highlighted {\n    background: #2d3748;\n    color: #e2e8f0;\n    padding: 16px;\n    border-radius: 8px;\n    overflow-x: auto;\n    margin: 16px 0;\n  }\n  \n  .keyword {\n    color: #f687b3;\n    font-weight: bold;\n  }\n</style>\n```\n\n**Usage:**\n```svelte\n<script>\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import SyntaxHighlightedCode from './SyntaxHighlightedCode.svelte';\n\n  const options = new MarkpageOptions()\n    .overrideBuiltinToken('code', SyntaxHighlightedCode);\n\n  const source = `\n\\`\\`\\`javascript\nfunction greet(name) {\n  return \\`Hello, \\${name}!\\`;\n}\n\nconst message = greet('World');\nconsole.log(message);\n\\`\\`\\`\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n## Advanced: Manual Marked Instance\n\nFor advanced use cases, you can provide your own Marked instance:\n\n```svelte\n<script>\n  import { Markdown, MarkpageOptions, Marked } from '@markpage/svelte';\n\n  const markedInstance = new Marked();\n  // Add custom Marked configuration\n  markedInstance.setOptions({ \n    breaks: true,\n    gfm: true \n  });\n\n  const options = new MarkpageOptions()\n    .addCustomComponent('Button', Button)\n    .useMarkedInstance(markedInstance);\n\n  const source = `\nLine breaks are now preserved\n\n<Button>Custom Button</Button>\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n## Extension Structure\n\nExtensions follow this structure:\n\n```typescript\ninterface MarkdownExtension {\n  name: string;                    // Token type name\n  level: 'block' | 'inline';       // Block or inline level\n  component: Component;            // Svelte component to render\n  start(src: string): number | undefined;  // Find start position\n  tokenizer(src: string): any;     // Parse the token\n}\n```\n\n### Extension Methods\n\n- **`start(src)`**: Returns the position where the extension should start parsing, or `undefined` if not found\n- **`tokenizer(src)`**: Parses the token from the source string and returns a token object\n\n### Token Object\n\nThe tokenizer should return an object with:\n\n- `type`: The token type name (should match the extension name)\n- `raw`: The raw markdown text that was parsed\n- `text`: The content text (without delimiters)\n- Any additional properties your component needs\n\n## Best Practices\n\n### 1. Keep Extensions Focused\n\nCreate extensions for specific purposes rather than trying to handle multiple syntaxes in one extension.\n\n### 2. Handle Edge Cases\n\nMake sure your tokenizer handles edge cases gracefully:\n\n```javascript\ntokenizer(src) {\n  if (!src.startsWith('$')) return;\n  const end = src.indexOf('$', 1);\n  if (end === -1) return; // Handle unclosed syntax\n  // ... rest of parsing\n}\n```\n\n### 3. Use Semantic Names\n\nChoose clear, descriptive names for your extensions:\n\n```javascript\n// Good\nname: 'math_inline'\nname: 'syntax_highlight'\n\n// Avoid\nname: 'custom1'\nname: 'special'\n```\n\n### 4. Test Your Extensions\n\nAlways test your extensions with various inputs to ensure they work correctly.\n\n## What's Next?\n\n- **[Custom Components](custom-components.md)** - Learn how to create and use custom components\n- **[Getting Started](getting-started.md)** - Back to the basics",
  "guides/installation.md": "# Installation\n\nFollow this guide to install and set up Markpage in your project.\n\n## Prerequisites\n\nBefore installing Markpage, make sure you have:\n\n- **Node.js 18+** - Required for modern JavaScript features\n- **npm or yarn** - Package manager for installing dependencies\n- **Any framework or none** - The package works with React, Vue, Svelte, Angular, or vanilla JS\n\n## Quick Install\n\nInstall the package using npm:\n\n```bash\nnpm install markpage\n```\n\nOr using yarn:\n\n```bash\nyarn add markpage\n```\n\n## Manual Setup\n\n### 1. Create a New Project (Any Framework)\n\nIf you're starting from scratch, create a new project with your preferred framework:\n\n```bash\n# For React\nnpm create react-app my-docs-site\n\n# For Vue\nnpm create vue@latest my-docs-site\n\n# For Svelte\nnpm create svelte@latest my-docs-site\n\n# For vanilla JS\nmkdir my-docs-site && cd my-docs-site\nnpm init -y\n```\n\n### 2. Install Markpage\n\n```bash\nnpm install markpage\n```\n\n### 3. Set Up Your Content Structure\n\nCreate a directory for your documentation content:\n\n```bash\nmkdir docs\n```\n\n### 4. Create Your First Content\n\nCreate a basic documentation structure:\n\n```bash\n# Create the main index file\necho '{\n  \"items\": [\n    { \"name\": \"getting-started\", \"type\": \"page\", \"label\": \"Getting Started\" }\n  ]\n}' > docs/.index.json\n\n# Create your first markdown file\necho '# Getting Started\n\nWelcome to your documentation site!\n\nThis is your first page created with Markpage.' > docs/getting-started.md\n```\n\n### 5. Build Your Documentation\n\nCreate a build script in your `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"build:docs\": \"node -e \\\"import('markpage/builder').then(({buildPages}) => buildPages('./docs', {appOutput: './src/lib/content', includeContent: true}))\\\"\"\n  }\n}\n```\n\nOr create a build script file:\n\n```typescript\n// scripts/build-docs.js\nimport { buildPages } from 'markpage/builder';\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  websiteOutput: './src/lib/content',\n  includeContent: true\n});\n```\n\n### 6. Use in Your App\n\nCreate a documentation page in your app:\n\n```typescript\n// Example for React\nimport { NavigationTree, loadContent } from 'markpage/renderer';\nimport navigationData from './content/navigation.json';\nimport contentBundle from './content/content.json';\n\nfunction DocsPage() {\n  const [currentPage, setCurrentPage] = useState(\"getting-started.md\");\n  const [pageContent, setPageContent] = useState<string | null>(null);\n  \n  useEffect(() => {\n    if (currentPage && contentBundle) {\n      loadContent(currentPage, contentBundle).then(setPageContent);\n    }\n  }, [currentPage]);\n  \n  return (\n    <div className=\"docs-layout\">\n      <nav className=\"sidebar\">\n        {/* Navigation will go here */}\n      </nav>\n      <main className=\"content\">\n        {pageContent ? <div dangerouslySetInnerHTML={{ __html: pageContent }} /> : 'Loading...'}\n      </main>\n    </div>\n  );\n}\n```\n\n## Content Structure\n\n### Basic Structure\n\nYour documentation should follow this structure:\n\n```\ndocs/\n├── .index.json              # Root navigation\n├── getting-started.md        # Getting started page\n├── guides/\n│   ├── .index.json          # Guides section navigation\n│   ├── installation.md      # Installation guide\n│   └── configuration.md     # Configuration guide\n└── api/\n    ├── .index.json          # API section navigation\n    └── reference.md         # API reference\n```\n\n### Index.json Format\n\nEach `.index.json` file defines the navigation structure for that directory:\n\n```json\n{\n  \"items\": [\n    {\n      \"name\": \"page-name\",\n      \"type\": \"page\",\n      \"label\": \"Page Display Name\"\n    },\n    {\n      \"name\": \"section-name\",\n      \"type\": \"section\",\n      \"label\": \"Section Display Name\"\n    }\n  ]\n}\n```\n\n### Item Properties\n\n- `name`: File/directory name (without extension)\n- `type`: Either `\"page\"` or `\"section\"`\n- `label`: Display label for navigation\n- `collapsed`: Optional boolean to collapse sections by default\n- `url`: Optional external URL\n\n## Build Configuration\n\n### Basic Build\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: true\n});\n\n### Advanced Build Options\n\n```typescript\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  websiteOutput: './src/lib/content',\n  staticOutput: './dist',\n  includeContent: true,\n  processor: customProcessor,\n  \n});\n```\n\n## CLI Usage\n\nYou can also use the CLI for quick builds:\n\n```bash\n# Build for app integration\nnpx markpage build ./docs --output ./src/lib/content\n\n# Generate static site\nnpx markpage static ./docs --output ./dist\n```\n\n## Next Steps\n\nNow that you have Markpage installed, check out:\n\n- [Configuration](./configuration.md) - Learn about build options and customization\n- [API Reference](../api/builder.md) - Complete API documentation\n- [Examples](../../packages/examples) - Working examples in the examples package\n\n## Troubleshooting\n\n### Common Issues\n\n**Module not found errors**: Make sure you're using Node.js 18+ and have installed the package correctly.\n\n**Build errors**: Check that your `.index.json` files are valid JSON and follow the correct format.\n\n**Content not loading**: Verify that your markdown files exist and are referenced correctly in the navigation.\n\n### Getting Help\n\n- Check the [API Reference](../api/builder.md) for detailed documentation\n- Look at the [examples](../../packages/examples) for working implementations\n- Review the [test suite](../../packages/tests) for usage patterns\n",
  "guides/configuration.md": "# Configuration\n\nLearn how to configure markpage for your project with detailed options and examples.\n\n## Basic Configuration\n\nThe simplest way to build your documentation:\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: true\n});\n```\n\n## Build Options\n\n### `appOutput`\nDirectory where app-specific files will be generated.\n\n```typescript\nawait buildPages('./docs', {\n  appOutput: './src/lib/content'\n});\n```\n\n**Generated files:**\n- `navigation.json` - Navigation structure\n- `content.json` - Content bundle (if `includeContent: true`)\n\n### `websiteOutput`\nDirectory where website-specific files will be generated.\n\n```typescript\nawait buildPages('./docs', {\n  websiteOutput: './src/lib/content'\n});\n```\n\n**Generated files:**\n- `navigation.json` - Navigation structure\n- `content.json` - Content bundle (if `includeContent: true`)\n\n### `includeContent`\nWhether to include content in the output bundle.\n\n```typescript\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: true  // Default: false\n});\n```\n\n### `staticOutput`\nDirectory for static site generation.\n\n```typescript\nawait buildPages('./docs', {\n  staticOutput: './dist'\n});\n```\n\n## Advanced Options\n\n### Custom Processors\n\nYou can provide custom content processors for advanced transformations:\n\n```typescript\nconst processor = {\n  process(content: string): string {\n    // Add table of contents\n    return addTableOfContents(content);\n  }\n};\n\nconst result = await buildPages('./docs', {\n  appOutput: './src/lib/content',\n  processor\n});\n```\n\n \n\n## Static Site Generation\n\nGenerate a complete static HTML site:\n\n```typescript\nimport { generateStaticSite } from 'markpage/builder';\n\nconst result = await generateStaticSite('./docs', './dist', {\n  title: 'My Documentation',\n  baseUrl: 'https://example.com',\n  includeIndex: true\n});\n```\n\n### Static Site Options\n\n#### `title`\nSite title for the generated HTML.\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  title: 'My Awesome Documentation'\n});\n```\n\n#### `baseUrl`\nBase URL for the site (used for absolute links).\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  baseUrl: 'https://docs.example.com'\n});\n```\n\n#### `css`\nCustom CSS content to include in the generated HTML.\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  css: `\n    body { font-family: 'Inter', sans-serif; }\n    .docs-content { max-width: 800px; margin: 0 auto; }\n  `\n});\n```\n\n#### `js`\nCustom JavaScript content to include in the generated HTML.\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  js: `\n    // Add syntax highlighting\n    hljs.highlightAll();\n  `\n});\n```\n\n#### `includeIndex`\nWhether to generate an index page.\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  includeIndex: true  // Default: false\n});\n```\n\n#### `indexTitle`\nTitle for the generated index page.\n\n```typescript\nawait generateStaticSite('./docs', './dist', {\n  includeIndex: true,\n  indexTitle: 'Documentation Home'\n});\n```\n\n## CLI Usage\n\n### Build Command\n\nBuild documentation for app integration:\n\n```bash\nnpx markpage build <content-path> --output <output-path>\n```\n\n**Options:**\n- `--output`: Output directory (required)\n\n**Examples:**\n```bash\n# Basic build\nnpx markpage build ./docs --output ./src/lib/content\n```\n\n### Static Command\n\nGenerate a complete static HTML site:\n\n```bash\nnpx markpage static <content-path> --output <output-path>\n```\n\n**Options:**\n- `--output`: Output directory (required)\n\n**Examples:**\n```bash\n# Basic static site\nnpx markpage static ./docs --output ./dist\n```\n\n## Environment Variables\n\nConfigure behavior using environment variables:\n\n### `SMP_DEBUG`\nEnable debug logging.\n\n```bash\nSMP_DEBUG=1 npx markpage build ./docs\n```\n\n### `SMP_VERBOSE`\nEnable verbose output.\n\n```bash\nSMP_VERBOSE=1 npx markpage build ./docs\n```\n\n## Configuration Files\n\n### Package.json Scripts\n\nAdd build scripts to your `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"build:docs\": \"markpage build ./docs --output ./src/lib/content --include-content\",\n    \"build:static\": \"markpage static ./docs ./dist --title \\\"My Documentation\\\" --include-index\",\n    \"dev:docs\": \"npm run build:docs && npm run dev\"\n  }\n}\n```\n\n### Build Scripts\n\nCreate dedicated build scripts for complex configurations:\n\n```typescript\n// scripts/build-docs.js\nimport { buildPages } from 'markpage/builder';\n\nconst processor = {\n  process(content: string): string {\n    // Custom processing logic\n    return content.replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>');\n  }\n};\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  websiteOutput: './src/lib/content',\n  includeContent: true,\n  processor\n});\n```\n\n## Error Handling\n\nThe builder functions throw errors for common issues:\n\n```typescript\ntry {\n  const result = await buildPages('./docs');\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    console.error('Content directory not found');\n  } else if (error.code === 'INVALID_INDEX') {\n    console.error('Invalid .index.json file');\n  } else {\n    console.error('Build failed:', error.message);\n  }\n}\n```\n\n## Performance Optimization\n\n### Large Documentation Sites\n\nFor large documentation sites, consider:\n\n```typescript\n// Build only what you need\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: false,  // Don't include content if not needed\n  processor: {\n    process(content: string): string {\n      // Optimize content processing\n      return content;\n    }\n  }\n});\n```\n\n### Caching\n\nImplement caching for faster rebuilds:\n\n```typescript\nimport { buildPages } from 'markpage/builder';\nimport { existsSync, readFileSync } from 'fs';\n\nconst cacheFile = './.docs-cache.json';\n\n// Check if cache exists and is valid\nif (existsSync(cacheFile)) {\n  const cache = JSON.parse(readFileSync(cacheFile, 'utf8'));\n  // Use cache if valid\n}\n\nconst result = await buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: true\n});\n\n// Save cache\n// ...\n```\n\n## Next Steps\n\nNow that you understand configuration, explore:\n\n- [Advanced Customization](./advanced/customization.md) - Learn about custom components and styling\n\n- [API Reference](../api/builder.md) - Complete API documentation\n",
  "guides/advanced/customization.md": "# Advanced Customization\n\nLearn how to customize markpage for your specific needs with advanced configuration options.\n\n## Custom Components\n\nYou can create custom components to extend the functionality of your documentation:\n\n```svelte\n<!-- src/lib/components/CustomComponent.svelte -->\n<script lang=\"ts\">\n\tlet { content } = $props<{ content: string }>();\n</script>\n\n<div class=\"custom-component\">\n\t{@html content}\n</div>\n\n<style>\n\t.custom-component {\n\t\tbackground: #f8f9fa;\n\t\tborder: 1px solid #e9ecef;\n\t\tborder-radius: 8px;\n\t\tpadding: 1rem;\n\t\tmargin: 1rem 0;\n\t}\n</style>\n```\n\n## Custom Processors\n\nCreate custom content processors for advanced transformations:\n\n```typescript\nconst customProcessor = {\n\tprocess(content: string): string {\n\t\t// Replace custom syntax with HTML\n\t\treturn content\n\t\t\t.replace(/:::(.+?):::/g, '<CustomComponent content=\"$1\" />')\n\t\t\t.replace(/\\[\\[(.+?)\\]\\]/g, '<InternalLink href=\"$1\" />');\n\t}\n};\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  processor: customProcessor\n});\n```\n\n## Custom Styling\n\n### CSS Customization\n\nOverride default styles with your own CSS:\n\n```css\n/* Custom documentation styles */\n.docs-content {\n\tfont-family: 'Inter', sans-serif;\n\tline-height: 1.7;\n}\n\n.docs-content h1 {\n\tcolor: #1a202c;\n\tborder-bottom: 3px solid #3182ce;\n}\n\n.docs-content code {\n\tbackground: #edf2f7;\n\tcolor: #2d3748;\n\tfont-weight: 500;\n}\n\n.docs-content pre {\n\tbackground: #2d3748;\n\tborder-radius: 12px;\n\tbox-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n}\n```\n\n### Theme System\n\nCreate theme variations:\n\n```typescript\nconst themes = {\n\tlight: {\n\t\tbackground: '#ffffff',\n\t\ttext: '#2d3748',\n\t\tprimary: '#3182ce',\n\t\tsecondary: '#718096'\n\t},\n\tdark: {\n\t\tbackground: '#1a202c',\n\t\ttext: '#e2e8f0',\n\t\tprimary: '#63b3ed',\n\t\tsecondary: '#a0aec0'\n\t}\n};\n```\n\n## Custom Navigation\n\n### Custom Navigation Components\n\nCreate custom navigation components:\n\n```svelte\n<!-- src/lib/components/CustomSidebar.svelte -->\n<script lang=\"ts\">\n\timport type { NavigationItem } from 'markpage';\n\t\n\tlet { items, currentPage } = $props<{\n\t\titems: NavigationItem[];\n\t\tcurrentPage: string;\n\t}>();\n\t\n\tfunction renderItem(item: NavigationItem): string {\n\t\tif (item.type === 'section') {\n\t\t\treturn `\n\t\t\t\t<div class=\"nav-section\">\n\t\t\t\t\t<h3 class=\"nav-section-title\">${item.label}</h3>\n\t\t\t\t\t${item.items?.map(renderItem).join('') || ''}\n\t\t\t\t</div>\n\t\t\t`;\n\t\t}\n\t\t\n\t\tconst isActive = currentPage === item.name + '.md';\n\t\treturn `\n\t\t\t<a href=\"/docs/${item.name}\" class=\"nav-item ${isActive ? 'active' : ''}\">\n\t\t\t\t${item.label}\n\t\t\t</a>\n\t\t`;\n\t}\n</script>\n\n<nav class=\"custom-sidebar\">\n\t{@html items.map(renderItem).join('')}\n</nav>\n\n<style>\n\t.custom-sidebar {\n\t\tbackground: #f7fafc;\n\t\tpadding: 1.5rem;\n\t\tborder-right: 1px solid #e2e8f0;\n\t}\n\t\n\t.nav-section-title {\n\t\tfont-size: 0.875rem;\n\t\tfont-weight: 600;\n\t\ttext-transform: uppercase;\n\t\tletter-spacing: 0.05em;\n\t\tcolor: #718096;\n\t\tmargin: 1.5rem 0 0.75rem 0;\n\t}\n\t\n\t.nav-item {\n\t\tdisplay: block;\n\t\tpadding: 0.5rem 0.75rem;\n\t\tcolor: #4a5568;\n\t\ttext-decoration: none;\n\t\tborder-radius: 6px;\n\t\tmargin: 0.25rem 0;\n\t\ttransition: all 0.2s;\n\t}\n\t\n\t.nav-item:hover {\n\t\tbackground: #edf2f7;\n\t\tcolor: #2d3748;\n\t}\n\t\n\t.nav-item.active {\n\t\tbackground: #3182ce;\n\t\tcolor: white;\n\t}\n</style>\n```\n\n## Custom Layouts\n\n### Page Layouts\n\nCreate different layouts for different types of content:\n\n```svelte\n<!-- src/lib/layouts/DocumentationLayout.svelte -->\n<script lang=\"ts\">\n\tlet { children, title, sidebar } = $props<{\n\t\tchildren: any;\n\t\ttitle: string;\n\t\tsidebar: any;\n\t}>();\n</script>\n\n<div class=\"doc-layout\">\n\t<header class=\"doc-header\">\n\t\t<h1>{title}</h1>\n\t</header>\n\t\n\t<div class=\"doc-body\">\n\t\t<aside class=\"doc-sidebar\">\n\t\t\t{@render sidebar()}\n\t\t</aside>\n\t\t\n\t\t<main class=\"doc-content\">\n\t\t\t{@render children()}\n\t\t</main>\n\t</div>\n</div>\n\n<style>\n\t.doc-layout {\n\t\tmin-height: 100vh;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n\t\n\t.doc-header {\n\t\tbackground: #2d3748;\n\t\tcolor: white;\n\t\tpadding: 1rem 2rem;\n\t}\n\t\n\t.doc-body {\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t}\n\t\n\t.doc-sidebar {\n\t\twidth: 280px;\n\t\tbackground: #f7fafc;\n\t\tborder-right: 1px solid #e2e8f0;\n\t}\n\t\n\t.doc-content {\n\t\tflex: 1;\n\t\tpadding: 2rem;\n\t}\n</style>\n```\n\n## Custom Markdown Extensions\n\n### Syntax Extensions\n\nExtend markdown syntax with custom processors or token components:\n\n```typescript\nconst markdownExtensions = {\n\t// Custom admonition blocks\n\tadmonition: {\n\t\tpattern: /^:::(\\w+)\\n([\\s\\S]*?)\\n:::$/gm,\n\t\treplacement: (match: string, type: string, content: string) => {\n\t\t\tconst icons = {\n\t\t\t\tinfo: 'ℹ️',\n\t\t\t\twarning: '⚠️',\n\t\t\t\terror: '❌',\n\t\t\t\tsuccess: '✅'\n\t\t\t};\n\t\t\t\n\t\t\treturn `\n\t\t\t\t<div class=\"admonition admonition-${type}\">\n\t\t\t\t\t<div class=\"admonition-header\">\n\t\t\t\t\t\t${icons[type as keyof typeof icons] || '📝'} ${type.charAt(0).toUpperCase() + type.slice(1)}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"admonition-content\">\n\t\t\t\t\t\t${content}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t`;\n\t\t}\n\t},\n\t\n\t// Custom callout blocks\n\tcallout: {\n\t\tpattern: /^\\[\\[(.+?)\\]\\]\\n([\\s\\S]*?)\\n\\[\\[\\/\\]\\]$/gm,\n\t\treplacement: (match: string, title: string, content: string) => {\n\t\t\treturn `\n\t\t\t\t<div class=\"callout\">\n\t\t\t\t\t<div class=\"callout-title\">${title}</div>\n\t\t\t\t\t<div class=\"callout-content\">\n\t\t\t\t\t\t${content}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t`;\n\t\t}\n\t}\n};\n\nconst processor = {\n\tprocess(content: string): string {\n\t\tlet processed = content;\n\t\t\n\t\t// Apply custom extensions\n\t\tObject.values(markdownExtensions).forEach(extension => {\n\t\t\tprocessed = processed.replace(extension.pattern, extension.replacement);\n\t\t});\n\t\t\n\t\treturn processed;\n\t}\n};\n\n```\n\n### Rendering custom tokens in Svelte\n\nYou can render custom markdown tokens by using the `MarkpageOptions` API to register extensions with their components.\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, Marked, MarkpageOptions } from '@markpage/svelte';\n  import MathInline from '$lib/components/MathInline.svelte';\n  import MathBlock from '$lib/components/MathBlock.svelte';\n\n  // Example: add simple $...$ (inline) and $$...$$ (block) tokenizers\n  function mathExtensionWithComponents() {\n    return {\n      extensions: [\n        {\n          name: 'math_block',\n          level: 'block' as const,\n          component: MathBlock,\n          start(src: string) { const i = src.indexOf('$$'); return i < 0 ? undefined : i; },\n          tokenizer(src: string) {\n            if (!src.startsWith('$$')) return;\n            const end = src.indexOf('$$', 2);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 2);\n            const text = src.slice(2, end).trim();\n            return { type: 'math_block', raw, text } as any;\n          }\n        },\n        {\n          name: 'math_inline',\n          level: 'inline' as const,\n          component: MathInline,\n          start(src: string) { const i = src.indexOf('$'); return i < 0 ? undefined : i; },\n          tokenizer(src: string) {\n            if (src.startsWith('$$')) return; // let block handle\n            if (!src.startsWith('$')) return;\n            const end = src.indexOf('$', 1);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 1);\n            const text = src.slice(1, end).trim();\n            return { type: 'math_inline', raw, text } as any;\n          }\n        }\n      ]\n    };\n  }\n\n  const markedInstance = new Marked();\n  markedInstance.use(mathExtensionWithComponents());\n\n  const options = new MarkpageOptions()\n    .extendMarkdown(mathExtensionWithComponents())\n    .useMarkedInstance(markedInstance);\n\n  export let source: string;\n</script>\n\n<Markdown {source} {options} />\n```\n\nResolution order for a token type `t`:\n- Extension components (from MarkpageOptions)\n- Built-in markdown component\n- Optional `unknownToken` fallback\n\nTo override a built-in token (e.g., `codespan`):\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import OverrideCodeSpan from '$lib/components/OverrideCodeSpan.svelte';\n\n  const options = new MarkpageOptions()\n    .overrideBuiltinToken('codespan', OverrideCodeSpan);\n\n  export let source = 'Inline `code` here';\n</script>\n\n<Markdown {source} {options} />\n```\n\nAlternatively, you can manually add to the extension components map:\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import OverrideCodeSpan from '$lib/components/OverrideCodeSpan.svelte';\n\n  const options = new MarkpageOptions();\n  // Manually add the extension component to override built-in codespan\n  const extensionComponents = options.getExtensionComponents();\n  extensionComponents.set('codespan', OverrideCodeSpan);\n\n  export let source = 'Inline `code` here';\n</script>\n\n<Markdown {source} {options} />\n```\n```\n\n## Custom Build Process\n\n### Build Hooks\n\nAdd custom build hooks for advanced processing:\n\n```typescript\nconst buildHooks = {\n\tbeforeBuild: async (contentPath: string) => {\n\t\tconsole.log('Starting build for:', contentPath);\n\t\t// Pre-processing tasks\n\t},\n\t\n\tafterBuild: async (result: any) => {\n\t\tconsole.log('Build completed:', result);\n\t\t// Post-processing tasks\n\t},\n\t\n\tonError: (error: Error) => {\n\t\tconsole.error('Build error:', error);\n\t\t// Error handling\n\t}\n};\n\nawait buildPages('./docs', {\n  appOutput: './src/lib/content',\n  hooks: buildHooks\n});\n```\n\n## Performance Optimization\n\n### Lazy Loading\n\nImplement lazy loading for large documentation sites:\n\n```typescript\nconst lazyProcessor = {\n\tprocess(content: string): string {\n\t\t// Add lazy loading attributes to images\n\t\treturn content.replace(\n\t\t\t/<img([^>]+)>/g,\n\t\t\t'<img$1 loading=\"lazy\">'\n\t\t);\n\t}\n};\n```\n\n### Code Splitting\n\nSplit large content into smaller chunks:\n\n```typescript\nconst chunkProcessor = {\n\tprocess(content: string): string {\n\t\t// Split content into sections\n\t\tconst sections = content.split(/(?=^#{1,3}\\s)/m);\n\t\t\n\t\treturn sections.map((section, index) => {\n\t\t\tif (index === 0) return section;\n\t\t\treturn `<section data-chunk=\"${index}\">${section}</section>`;\n\t\t}).join('');\n\t}\n};\n```\n\n## Next Steps\n\nNow that you understand advanced customization, explore:\n\n\n- [API Reference](../api/builder.md) - Complete API documentation\n- [Examples](../../packages/examples) - Working examples\n",
  "api/builder.md": "# Builder API\n\nThe builder module provides functions for building documentation from markdown content and generating various output formats.\n\n## Functions\n\n### `buildPages(contentPath, options?)`\n\nBuilds documentation from a content directory.\n\n**Parameters:**\n- `contentPath` (string): Path to the content directory\n- `options` (BuildOptions, optional): Build configuration options\n\n**Returns:** Promise<BuildResult>\n\n**Example:**\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nconst result = await buildPages('./docs', {\n  appOutput: './src/lib/content',\n  websiteOutput: './src/lib/content',\n  includeContent: true\n});\n```\n\n### `generateStaticSite(contentPath, outputPath, options?)`\n\nGenerates a complete static HTML site from markdown content.\n\n**Parameters:**\n- `contentPath` (string): Path to the content directory\n- `outputPath` (string): Path where the static site will be generated\n- `options` (StaticSiteOptions, optional): Static site configuration options\n\n**Returns:** Promise<StaticSiteResult>\n\n**Example:**\n```typescript\nimport { generateStaticSite } from 'markpage/builder';\n\nconst result = await generateStaticSite('./docs', './dist', {\n  title: 'My Documentation',\n  baseUrl: 'https://example.com',\n  includeIndex: true\n});\n```\n\n## Types\n\n### BuildOptions\n\nConfiguration options for the `buildPages` function.\n\n```typescript\ninterface BuildOptions {\n  appOutput?: string;\n  websiteOutput?: string;\n  staticOutput?: string;\n  includeContent?: boolean;\n}\n```\n\n**Properties:**\n- `appOutput` (string, optional): Directory for app-specific output files\n- `websiteOutput` (string, optional): Directory for website-specific output files\n- `staticOutput` (string, optional): Directory for static site output\n- `includeContent` (boolean, optional): Whether to include content in output bundles (default: false)\n\n### StaticSiteOptions\n\nConfiguration options for the `generateStaticSite` function.\n\n```typescript\ninterface StaticSiteOptions {\n  title?: string;\n  baseUrl?: string;\n  css?: string;\n  js?: string;\n  processor?: ContentProcessor;\n  includeIndex?: boolean;\n  indexTitle?: string;\n}\n```\n\n**Properties:**\n- `title` (string, optional): Site title for generated HTML\n- `baseUrl` (string, optional): Base URL for the site\n- `css` (string, optional): Custom CSS content to include\n- `js` (string, optional): Custom JavaScript content to include\n- `processor` (ContentProcessor, optional): Custom content processor\n- `includeIndex` (boolean, optional): Whether to generate an index page (default: false)\n- `indexTitle` (string, optional): Title for the generated index page\n\n### BuildResult\n\nResult object returned by `buildPages`.\n\n```typescript\ninterface BuildResult {\n  navigation: NavigationTree;\n  content?: Record<string, string>;\n  pages?: Array<{\n    path: string;\n    content: string;\n    html: string;\n  }>;\n}\n```\n\n**Properties:**\n- `navigation` (NavigationTree): Generated navigation structure\n- `content` (Record<string, string>, optional): Content bundle (if includeContent is true)\n- `pages` (Array, optional): Array of generated pages with path, content, and HTML\n\n### StaticSiteResult\n\nResult object returned by `generateStaticSite`.\n\n```typescript\ninterface StaticSiteResult {\n  files: string[];\n  stats: BuildStats;\n  urls: string[];\n}\n```\n\n**Properties:**\n- `files` (string[]): List of generated files\n- `stats` (BuildStats): Build statistics\n- `urls` (string[]): List of generated URLs\n\n### ContentProcessor\n\nInterface for custom content processors.\n\n```typescript\ninterface ContentProcessor {\n  process(content: string): string;\n}\n```\n\n**Methods:**\n- `process(content: string): string`: Process and transform content\n\n### Plugin\n\nInterface for plugins.\n\n```typescript\ninterface Plugin {\n  name: string;\n  version: string;\n  process?: (content: string) => string;\n  transform?: (content: string) => string;\n  validate?: (content: string) => boolean;\n  beforeBuild?: () => void;\n  afterBuild?: (result: any) => void;\n}\n```\n\n**Properties:**\n- `name` (string): Plugin name\n- `version` (string): Plugin version\n- `process` (function, optional): Content processing function\n- `transform` (function, optional): Content transformation function\n- `validate` (function, optional): Content validation function\n- `beforeBuild` (function, optional): Pre-build hook\n- `afterBuild` (function, optional): Post-build hook\n\n### BuildHooks\n\nLifecycle hooks for the build process.\n\n```typescript\ninterface BuildHooks {\n  beforeBuild?: (contentPath: string) => void | Promise<void>;\n  afterBuild?: (result: BuildResult) => void | Promise<void>;\n  onError?: (error: Error) => void;\n}\n```\n\n**Properties:**\n- `beforeBuild` (function, optional): Called before build starts\n- `afterBuild` (function, optional): Called after build completes\n- `onError` (function, optional): Called when build errors occur\n\n\n\n## Examples\n\n### Basic Build\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nconst result = await buildPages('./docs', {\n  appOutput: './src/lib/content',\n  includeContent: true\n});\n\nconsole.log(`Built navigation with ${result.navigation.items.length} root items`);\n```\n\n### Advanced Build with Custom Processor\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\nconst customProcessor = {\n  process(content: string): string {\n    return content.replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>');\n  }\n};\n\nconst result = await buildPages('./docs', {\n  appOutput: './src/lib/content',\n  websiteOutput: './src/lib/content',\n  includeContent: true,\n  processor: customProcessor\n});\n```\n\n### Static Site Generation\n\n```typescript\nimport { generateStaticSite } from 'markpage/builder';\n\nconst result = await generateStaticSite('./docs', './dist', {\n  title: 'My Documentation',\n  baseUrl: 'https://docs.example.com',\n  css: `\n    body { font-family: 'Inter', sans-serif; }\n    .docs-content { max-width: 800px; margin: 0 auto; }\n  `,\n  js: `\n    // Add syntax highlighting\n    hljs.highlightAll();\n  `,\n  includeIndex: true,\n  indexTitle: 'Documentation Home'\n});\n\nconsole.log(`Generated ${result.pages?.length || 0} pages`);\nconsole.log(`Available URLs: ${result.urls.join(', ')}`);\n```\n\n### Error Handling\n\n```typescript\nimport { buildPages } from 'markpage/builder';\n\ntry {\n  const result = await buildPages('./docs', {\n    appOutput: './src/lib/content',\n    includeContent: true\n  });\n  \n  if (result.stats.errors.length > 0) {\n    console.error('Build completed with errors:', result.stats.errors);\n  }\n  \n  if (result.stats.warnings.length > 0) {\n    console.warn('Build completed with warnings:', result.stats.warnings);\n  }\n} catch (error) {\n  console.error('Build failed:', error.message);\n  process.exit(1);\n}\n```\n\n## Error Codes\n\nThe builder functions may throw errors with specific error codes:\n\n- `ENOENT`: Content directory not found\n- `INVALID_INDEX`: Invalid `.index.json` file\n- `MISSING_CONTENT`: Required content file missing\n- `PROCESSING_ERROR`: Content processing failed\n- `PLUGIN_ERROR`: Plugin execution failed\n\n## Performance Considerations\n\n### Large Documentation Sites\n\nFor large documentation sites, consider:\n\n1. **Disable content inclusion** if not needed:\n   ```typescript\n   await buildPages('./docs', {\n     appOutput: './src/lib/content',\n     includeContent: false\n   });\n   ```\n\n2. **Use efficient processors**:\n   ```typescript\n   const efficientProcessor = {\n     process(content: string): string {\n       // Use efficient string operations\n       return content.replace(/pattern/g, 'replacement');\n     }\n   };\n   ```\n\n3. **Implement caching**:\n   ```typescript\n   const cache = new Map();\n   \n   const cachedProcessor = {\n     process(content: string): string {\n       const hash = createHash(content);\n       if (cache.has(hash)) {\n         return cache.get(hash);\n       }\n       \n       const result = processContent(content);\n       cache.set(hash, result);\n       return result;\n     }\n   };\n   ```\n\n## Related\n\n- [Renderer API](./renderer.md) - Content rendering and navigation\n- [Types](./types.md) - Type definitions and interfaces\n",
  "api/renderer.md": "# Renderer API\n\nThe renderer module provides classes and functions for managing content and navigation in your applications.\n\n## Classes\n\n### `NavigationTree`\n\nManages navigation structure and provides navigation utilities.\n\n```typescript\nimport { NavigationTree } from 'markpage/renderer';\n\nconst navigation = new NavigationTree(navigationData);\n```\n\n#### Constructor\n\n**Parameters:**\n- `navigationData` (NavigationData): Navigation structure data\n\n#### Methods\n\n##### `findItemByPath(path: string): NavigationItem | undefined`\n\nFinds a navigation item by its file path.\n\n**Parameters:**\n- `path` (string): File path to search for\n\n**Returns:** NavigationItem | undefined\n\n**Example:**\n```typescript\nconst item = navigation.findItemByPath('guides/installation.md');\nif (item) {\n  console.log('Found item:', item.label);\n}\n```\n\n##### `getBreadcrumbs(path: string): NavigationItem[]`\n\nGets the breadcrumb trail for a given path.\n\n**Parameters:**\n- `path` (string): File path to get breadcrumbs for\n\n**Returns:** NavigationItem[]\n\n**Example:**\n```typescript\nconst breadcrumbs = navigation.getBreadcrumbs('guides/advanced/customization.md');\n// Returns: [root, guides, advanced, customization]\n```\n\n##### `getSiblings(path: string): NavigationItem[]`\n\nGets sibling items for a given path.\n\n**Parameters:**\n- `path` (string): File path to get siblings for\n\n**Returns:** NavigationItem[]\n\n**Example:**\n```typescript\nconst siblings = navigation.getSiblings('guides/installation.md');\n// Returns: [installation, configuration, advanced]\n```\n\n##### `getNextSibling(path: string): NavigationItem | undefined`\n\nGets the next sibling item.\n\n**Parameters:**\n- `path` (string): Current file path\n\n**Returns:** NavigationItem | undefined\n\n**Example:**\n```typescript\nconst next = navigation.getNextSibling('guides/installation.md');\nif (next) {\n  console.log('Next page:', next.label);\n}\n```\n\n##### `getPreviousSibling(path: string): NavigationItem | undefined`\n\nGets the previous sibling item.\n\n**Parameters:**\n- `path` (string): Current file path\n\n**Returns:** NavigationItem | undefined\n\n**Example:**\n```typescript\nconst prev = navigation.getPreviousSibling('guides/configuration.md');\nif (prev) {\n  console.log('Previous page:', prev.label);\n}\n```\n\n##### `getChildren(path: string): NavigationItem[]`\n\nGets child items for a given path.\n\n**Parameters:**\n- `path` (string): Parent path to get children for\n\n**Returns:** NavigationItem[]\n\n**Example:**\n```typescript\nconst children = navigation.getChildren('guides');\n// Returns: [installation, configuration, advanced]\n```\n\n##### `findItemByName(name: string): NavigationItem | undefined`\n\nFinds a navigation item by its name.\n\n**Parameters:**\n- `path` (string): Item name to search for\n\n**Returns:** NavigationItem | undefined\n\n**Example:**\n```typescript\nconst item = navigation.findItemByName('installation');\nif (item) {\n  console.log('Found item:', item.label);\n}\n```\n\n##### `isExpanded(path: string): boolean`\n\nChecks if a section is expanded.\n\n**Parameters:**\n- `path` (string): Path to check\n\n**Returns:** boolean\n\n**Example:**\n```typescript\nconst expanded = navigation.isExpanded('guides');\nconsole.log('Guides section expanded:', expanded);\n```\n\n##### `toggleExpanded(path: string): void`\n\nToggles the expanded state of a section.\n\n**Parameters:**\n- `path` (string): Path to toggle\n\n**Example:**\n```typescript\nnavigation.toggleExpanded('guides');\n```\n\n##### `getChildren(path: string): NavigationItem[]`\n\nGets child items for a given path.\n\n**Parameters:**\n- `path` (string): Parent path to get children for\n\n**Returns:** NavigationItem[]\n\n**Example:**\n```typescript\nconst children = navigation.getChildren('guides');\n// Returns: [installation, configuration, advanced]\n```\n\n##### `getParent(path: string): NavigationItem | null`\n\nGets the parent item for a given path.\n\n**Parameters:**\n- `path` (string): Child path to get parent for\n\n**Returns:** NavigationItem | null\n\n**Example:**\n```typescript\nconst parent = navigation.getParent('guides/installation.md');\nif (parent) {\n  console.log('Parent section:', parent.label);\n}\n```\n\n### `ContentLoader`\n\nManages content loading and processing.\n\n```typescript\nimport { ContentLoader } from 'markpage/renderer';\n\nconst loader = new ContentLoader(contentBundle);\n```\n\n#### Constructor\n\n**Parameters:**\n- `contentBundle` (ContentBundle): Content bundle data\n\n#### Methods\n\n##### `loadAndProcess(path: string, processor?: ContentProcessor): string`\n\nLoads and processes content for a specific path.\n\n**Parameters:**\n- `path` (string): Content path to load\n- `processor` (ContentProcessor, optional): Custom content processor\n\n**Returns:** string\n\n**Example:**\n```typescript\nconst content = loader.loadAndProcess('getting-started.md');\nconsole.log('Content loaded:', content.length, 'characters');\n```\n\n##### `hasContent(path: string): boolean`\n\nChecks if content exists for a given path.\n\n**Parameters:**\n- `path` (string): Content path to check\n\n**Returns:** boolean\n\n**Example:**\n```typescript\nif (loader.hasContent('guides/installation.md')) {\n  console.log('Installation guide exists');\n}\n```\n\n##### `getAvailablePaths(): string[]`\n\nGets all available content paths.\n\n**Returns:** string[]\n\n**Example:**\n```typescript\nconst paths = loader.getAvailablePaths();\nconsole.log('Available content:', paths);\n```\n\n##### `getContentMetadata(path: string): ContentMetadata | null`\n\nGets metadata for a content file.\n\n**Parameters:**\n- `path` (string): Content path to get metadata for\n\n**Returns:** ContentMetadata | null\n\n**Example:**\n```typescript\nconst metadata = loader.getContentMetadata('getting-started.md');\nif (metadata) {\n  console.log('Title:', metadata.title);\n  console.log('Last modified:', metadata.lastModified);\n}\n```\n\n## Functions\n\n### `loadContent(path, contentBundle, processor?)`\n\nLoads and processes content for a specific path.\n\n**Parameters:**\n- `path` (string): Content path to load\n- `contentBundle` (ContentBundle): Content bundle data\n- `processor` (ContentProcessor, optional): Custom content processor\n\n**Returns:** Promise<string | undefined>\n\n**Example:**\n```typescript\nimport { loadContent } from 'markpage/renderer';\n\nconst content = await loadContent('getting-started.md', contentBundle);\n```\n\n### `extractHeadings(content: string): Heading[]`\n\nExtracts headings from markdown content.\n\n**Parameters:**\n- `content` (string): Markdown content to extract headings from\n\n**Returns:** Heading[]\n\n**Example:**\n```typescript\nimport { extractHeadings } from 'markpage/renderer';\n\nconst headings = extractHeadings(content);\nheadings.forEach(heading => {\n  console.log(`${'#'.repeat(heading.level)} ${heading.text}`);\n});\n```\n\n### `extractTableOfContents(content: string): TableOfContentsItem[]`\n\nExtracts table of contents from markdown content.\n\n**Parameters:**\n- `content` (string): Markdown content to extract TOC from\n\n**Returns:** TableOfContentsItem[]\n\n**Example:**\n```typescript\nimport { extractTableOfContents } from 'markpage/renderer';\n\nconst toc = extractTableOfContents(content);\ntoc.forEach(item => {\n  console.log(`${'  '.repeat(item.depth)}- ${item.text}`);\n});\n```\n\n### `addTableOfContents(content: string, toc?: TableOfContentsItem[]): string`\n\nAdds a table of contents to markdown content.\n\n**Parameters:**\n- `content` (string): Markdown content to add TOC to\n- `toc` (TableOfContentsItem[], optional): Pre-generated TOC\n\n**Returns:** string\n\n**Example:**\n```typescript\nimport { addTableOfContents } from 'markpage/renderer';\n\nconst contentWithToc = addTableOfContents(content);\n```\n\n## Types\n\n### NavigationItem\n\nRepresents a navigation item.\n\n```typescript\ninterface NavigationItem {\n  name: string;\n  type: 'page' | 'section';\n  label: string;\n  items?: NavigationItem[];\n  collapsed?: boolean;\n  url?: string;\n}\n```\n\n**Properties:**\n- `name` (string): File/directory name (without extension)\n- `type` ('page' | 'section'): Item type\n- `label` (string): Display label\n- `items` (NavigationItem[], optional): Child items (for sections)\n- `collapsed` (boolean, optional): Whether section is collapsed by default\n- `url` (string, optional): External URL\n\n### NavigationData\n\nComplete navigation structure.\n\n```typescript\ninterface NavigationData {\n  items: NavigationItem[];\n}\n```\n\n### ContentBundle\n\nBundle containing all content data.\n\n```typescript\ninterface ContentBundle {\n  [path: string]: string;\n}\n```\n\n### ContentMetadata\n\nMetadata for a content file.\n\n```typescript\ninterface ContentMetadata {\n  title: string;\n  description?: string;\n  lastModified: Date;\n  wordCount: number;\n  readingTime: number;\n}\n```\n\n### Heading\n\nRepresents a markdown heading.\n\n```typescript\ninterface Heading {\n  level: number;\n  text: string;\n  id: string;\n  line: number;\n}\n```\n\n**Properties:**\n- `level` (number): Heading level (1-6)\n- `text` (string): Heading text\n- `id` (string): Generated heading ID\n- `line` (number): Line number in source\n\n### TableOfContentsItem\n\nRepresents a table of contents item.\n\n```typescript\ninterface TableOfContentsItem {\n  level: number;\n  text: string;\n  id: string;\n  children: TableOfContentsItem[];\n}\n```\n\n**Properties:**\n- `level` (number): Heading level\n- `text` (string): Heading text\n- `id` (string): Heading ID\n- `children` (TableOfContentsItem[]): Child items\n\n### ContentProcessor\n\nInterface for content processors.\n\n```typescript\ninterface ContentProcessor {\n  process(content: string): string;\n}\n```\n\n## Examples\n\n### Basic Navigation Usage\n\n```typescript\nimport { NavigationTree } from 'markpage/renderer';\nimport navigationData from './content/navigation.json';\n\nconst navigation = new NavigationTree(navigationData);\n\n// Find current page\nconst currentPage = navigation.findItemByPath('guides/installation.md');\n\n// Get breadcrumbs\nconst breadcrumbs = navigation.getBreadcrumbs('guides/installation.md');\n\n// Get navigation siblings\nconst nextPage = navigation.getNextSibling('guides/installation.md');\nconst prevPage = navigation.getPreviousSibling('guides/installation.md');\n```\n\n### Content Loading\n\n```typescript\nimport { ContentLoader, loadContent } from 'markpage/renderer';\nimport contentBundle from './content/content.json';\n\n// Using ContentLoader class\nconst loader = new ContentLoader(contentBundle);\nconst content = loader.loadAndProcess('getting-started.md');\n\n// Using loadContent function\nconst content = await loadContent('getting-started.md', contentBundle);\n```\n\n### Table of Contents\n\n```typescript\nimport { \n  extractHeadings, \n  extractTableOfContents, \n  addTableOfContents \n} from 'markpage/renderer';\n\n// Extract headings\nconst headings = extractHeadings(content);\n\n// Generate table of contents\nconst toc = extractTableOfContents(content);\n\n// Add table of contents to content\nconst contentWithToc = addTableOfContents(content, toc);\n```\n\n### Custom Content Processing\n### Svelte Markdown: Custom Components and Extensions\n\nRender markdown in Svelte with custom components and extensions using the new `MarkpageOptions` API:\n\n#### Custom Components with Nested Content\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import Button from '$lib/components/Button.svelte';\n  import Alert from '$lib/components/Alert.svelte';\n  import Card from '$lib/components/Card.svelte';\n\n  const options = new MarkpageOptions()\n    .addCustomComponent('Button', Button)\n    .addCustomComponent('Alert', Alert)\n    .addCustomComponent('Card', Card);\n\n  const source = `\n<Card title=\"Nested Components Example\">\n  <Alert variant=\"info\">\n    This alert contains **markdown** content and other components:\n    \n    <Button variant=\"primary\">Nested Button</Button>\n  </Alert>\n</Card>\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n#### Markdown Extensions (LaTeX Math)\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import MathInline from '$lib/components/MathInline.svelte';\n  import MathBlock from '$lib/components/MathBlock.svelte';\n\n  function mathExtension() {\n    return {\n      extensions: [\n        {\n          name: 'math_block',\n          level: 'block' as const,\n          component: MathBlock,\n          start: (src: string) => {\n            const i = src.indexOf('$$');\n            return i < 0 ? undefined : i;\n          },\n          tokenizer(src: string) {\n            if (!src.startsWith('$$')) return;\n            const end = src.indexOf('$$', 2);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 2);\n            const text = src.slice(2, end).trim();\n            return { type: 'math_block', raw, text } as any;\n          }\n        },\n        {\n          name: 'math_inline',\n          level: 'inline' as const,\n          component: MathInline,\n          start: (src: string) => {\n            const i = src.indexOf('$');\n            return i < 0 ? undefined : i;\n          },\n          tokenizer(src: string) {\n            if (src.startsWith('$$')) return; // let block handle\n            if (!src.startsWith('$')) return;\n            const end = src.indexOf('$', 1);\n            if (end === -1) return;\n            const raw = src.slice(0, end + 1);\n            const text = src.slice(1, end).trim();\n            return { type: 'math_inline', raw, text } as any;\n          }\n        }\n      ]\n    };\n  }\n\n  const options = new MarkpageOptions()\n    .extendMarkdown(mathExtension());\n\n  const source = 'Here is inline $E = mc^2$ and a block:\\n\\n$$\\n\\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} dx = \\\\sqrt{\\\\pi}\\n$$';\n</script>\n\n<Markdown {source} {options} />\n```\n\n#### Override Built-in Tokens\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions } from '@markpage/svelte';\n  import CustomCodeSpan from '$lib/components/CustomCodeSpan.svelte';\n  import CustomHeading from '$lib/components/CustomHeading.svelte';\n\n  const options = new MarkpageOptions()\n    .overrideBuiltinToken('codespan', CustomCodeSpan)\n    .overrideBuiltinToken('heading', CustomHeading);\n\n  const source = `\n# Custom Heading\n\nHere is \\`inline code\\` with custom styling!\n  `;\n</script>\n\n<Markdown {source} {options} />\n```\n\n#### Advanced: Manual Marked Instance\n\n```svelte\n<script lang=\"ts\">\n  import { Markdown, MarkpageOptions, Marked } from '@markpage/svelte';\n\n  const markedInstance = new Marked();\n  // Add custom Marked configuration\n  markedInstance.setOptions({ breaks: true });\n\n  const options = new MarkpageOptions()\n    .addCustomComponent('Button', Button)\n    .useMarkedInstance(markedInstance);\n\n  const source = 'Line breaks are now preserved\\n\\n<Button>Custom Button</Button>';\n</script>\n\n<Markdown {source} {options} />\n```\n\n```typescript\nimport { loadContent } from 'markpage/renderer';\n\nconst customProcessor = {\n  process(content: string): string {\n    // Add custom processing\n    return content\n      .replace(/:::(.+?):::/g, '<CustomComponent>$1</CustomComponent>')\n      .replace(/\\[\\[(.+?)\\]\\]/g, '<InternalLink>$1</InternalLink>');\n  }\n};\n\nconst processedContent = await loadContent(\n  'getting-started.md', \n  contentBundle, \n  customProcessor\n);\n```\n\n### React Component Integration\n\n```tsx\n// src/components/DocsLayout.tsx\nimport React, { useState, useEffect } from 'react';\nimport { NavigationTree, loadContent } from 'markpage/renderer';\nimport type { NavigationItem } from 'markpage';\nimport navigationData from '../content/navigation.json';\nimport contentBundle from '../content/content.json';\n\nfunction DocsLayout() {\n  const [navigation] = useState(() => new NavigationTree(navigationData));\n  const [currentPage, setCurrentPage] = useState<string>(\"getting-started.md\");\n  const [pageContent, setPageContent] = useState<string | null>(null);\n  \n  useEffect(() => {\n    if (currentPage && contentBundle) {\n      loadContent(currentPage, contentBundle).then(setPageContent);\n    }\n  }, [currentPage]);\n  \n  function handlePageSelect(path: string) {\n    setCurrentPage(path);\n  }\n  \n  function renderNavigationItems(items: NavigationItem[]) {\n    return items.map(item => {\n      if (item.type === 'section') {\n        return (\n          <div key={item.name} className=\"nav-section\">\n            <h3>{item.label}</h3>\n            {renderNavigationItems(item.items || [])}\n          </div>\n        );\n      } else {\n        const isActive = currentPage === item.name + '.md';\n        return (\n          <button \n            key={item.name}\n            className={`nav-link ${isActive ? 'active' : ''}`}\n            onClick={() => handlePageSelect(item.name + '.md')}\n          >\n            {item.label}\n          </button>\n        );\n      }\n    });\n  }\n  \n  return (\n    <div className=\"docs-layout\">\n      <nav className=\"docs-sidebar\">\n        {renderNavigationItems(navigation.items)}\n      </nav>\n      \n      <div className=\"docs-content\">\n        {pageContent ? <div dangerouslySetInnerHTML={{ __html: pageContent }} /> : 'No content selected'}\n      </div>\n    </div>\n  );\n}\n```\n\n## Error Handling\n\n### Content Loading Errors\n\n```typescript\nimport { loadContent } from 'markpage/renderer';\n\ntry {\n  const content = await loadContent('non-existent.md', contentBundle);\n} catch (error) {\n  if (error.code === 'CONTENT_NOT_FOUND') {\n    console.error('Content not found');\n  } else {\n    console.error('Failed to load content:', error.message);\n  }\n}\n```\n\n### Navigation Errors\n\n```typescript\nimport { NavigationTree } from 'markpage/renderer';\n\ntry {\n  const navigation = new NavigationTree(navigationData);\n  const item = navigation.findItemByPath('invalid/path.md');\n  \n  if (!item) {\n    console.warn('Navigation item not found');\n  }\n} catch (error) {\n  console.error('Navigation error:', error.message);\n}\n```\n\n## Performance Considerations\n\n### Lazy Loading\n\nFor large content bundles, consider lazy loading:\n\n```typescript\nconst lazyLoader = {\n  async loadContent(path: string): Promise<string> {\n    // Load content on demand\n    const response = await fetch(`/api/content/${path}`);\n    return response.text();\n  }\n};\n```\n\n### Caching\n\nImplement caching for frequently accessed content:\n\n```typescript\nconst contentCache = new Map();\n\nasync function loadContentWithCache(path: string, contentBundle: any): Promise<string> {\n  if (contentCache.has(path)) {\n    return contentCache.get(path);\n  }\n  \n  const content = await loadContent(path, contentBundle);\n  contentCache.set(path, content);\n  return content;\n}\n```\n\n## Related\n\n- [Builder API](./builder.md) - Content building and generation\n- [Types](./types.md) - Type definitions and interfaces\n",
  "api/types.md": "# Types\n\nComplete type definitions and interfaces for markpage.\n\n## Core Types\n\n### NavigationItem\n\nRepresents a navigation item in the documentation structure.\n\n```typescript\ninterface NavigationItem {\n  name: string;\n  type: 'page' | 'section';\n  label: string;\n  items?: NavigationItem[];\n  collapsed?: boolean;\n  url?: string;\n}\n```\n\n**Properties:**\n- `name` (string): File/directory name without extension\n- `type` ('page' | 'section'): Type of navigation item\n- `label` (string): Display label for the item\n- `items` (NavigationItem[], optional): Child items for sections\n- `collapsed` (boolean, optional): Whether section is collapsed by default\n- `url` (string, optional): External URL for the item\n\n### NavigationData\n\nComplete navigation structure for the documentation.\n\n```typescript\ninterface NavigationData {\n  items: NavigationItem[];\n}\n```\n\n**Properties:**\n- `items` (NavigationItem[]): Root-level navigation items\n\n### ContentBundle\n\nBundle containing all content data indexed by file path.\n\n```typescript\ninterface ContentBundle {\n  [path: string]: string;\n}\n```\n\n**Properties:**\n- `[path: string]` (string): Content indexed by file path\n\n## Builder Types\n\n### BuildOptions\n\nConfiguration options for the `buildPages` function.\n\n```typescript\ninterface BuildOptions {\n  appOutput?: string;\n  websiteOutput?: string;\n  staticOutput?: string;\n  includeContent?: boolean;\n  processor?: ContentProcessor;\n  plugins?: Plugin[];\n  hooks?: BuildHooks;\n}\n```\n\n**Properties:**\n- `appOutput` (string, optional): Directory for app-specific output files\n- `websiteOutput` (string, optional): Directory for website-specific output files\n- `staticOutput` (string, optional): Directory for static site output\n- `includeContent` (boolean, optional): Whether to include content in output bundles\n- `processor` (ContentProcessor, optional): Custom content processor\n- `plugins` (Plugin[], optional): Array of plugins to apply\n- `hooks` (BuildHooks, optional): Build lifecycle hooks\n\n### StaticSiteOptions\n\nConfiguration options for the `generateStaticSite` function.\n\n```typescript\ninterface StaticSiteOptions {\n  title?: string;\n  baseUrl?: string;\n  css?: string;\n  js?: string;\n  includeIndex?: boolean;\n  indexTitle?: string;\n  processor?: ContentProcessor;\n  plugins?: Plugin[];\n}\n```\n\n**Properties:**\n- `title` (string, optional): Site title for generated HTML\n- `baseUrl` (string, optional): Base URL for the site\n- `css` (string, optional): Custom CSS content to include\n- `js` (string, optional): Custom JavaScript content to include\n- `includeIndex` (boolean, optional): Whether to generate an index page\n- `indexTitle` (string, optional): Title for the generated index page\n- `processor` (ContentProcessor, optional): Custom content processor\n- `plugins` (Plugin[], optional): Array of plugins to apply\n\n### BuildResult\n\nResult object returned by `buildPages`.\n\n```typescript\ninterface BuildResult {\n  navigation: NavigationData;\n  content?: ContentBundle;\n  files: string[];\n  stats: BuildStats;\n}\n```\n\n**Properties:**\n- `navigation` (NavigationData): Generated navigation structure\n- `content` (ContentBundle, optional): Content bundle (if includeContent is true)\n- `files` (string[]): List of generated files\n- `stats` (BuildStats): Build statistics\n\n### StaticSiteResult\n\nResult object returned by `generateStaticSite`.\n\n```typescript\ninterface StaticSiteResult {\n  files: string[];\n  stats: BuildStats;\n  urls: string[];\n}\n```\n\n**Properties:**\n- `files` (string[]): List of generated files\n- `stats` (BuildStats): Build statistics\n- `urls` (string[]): List of generated URLs\n\n### BuildStats\n\nStatistics about the build process.\n\n```typescript\ninterface BuildStats {\n  pages: number;\n  sections: number;\n  totalFiles: number;\n  buildTime: number;\n  errors: string[];\n  warnings: string[];\n}\n```\n\n**Properties:**\n- `pages` (number): Number of pages processed\n- `sections` (number): Number of sections processed\n- `totalFiles` (number): Total number of files processed\n- `buildTime` (number): Build time in milliseconds\n- `errors` (string[]): List of build errors\n- `warnings` (string[]): List of build warnings\n\n\n\n## Renderer Types\n\n### ContentMetadata\n\nMetadata for a content file.\n\n```typescript\ninterface ContentMetadata {\n  title: string;\n  description?: string;\n  lastModified: Date;\n  wordCount: number;\n  readingTime: number;\n}\n```\n\n**Properties:**\n- `title` (string): Content title\n- `description` (string, optional): Content description\n- `lastModified` (Date): Last modification date\n- `wordCount` (number): Number of words in content\n- `readingTime` (number): Estimated reading time in minutes\n\n### Heading\n\nRepresents a markdown heading.\n\n```typescript\ninterface Heading {\n  level: number;\n  text: string;\n  id: string;\n  line: number;\n}\n```\n\n**Properties:**\n- `level` (number): Heading level (1-6)\n- `text` (string): Heading text\n- `id` (string): Generated heading ID\n- `line` (number): Line number in source\n\n### TableOfContentsItem\n\nRepresents a table of contents item.\n\n```typescript\ninterface TableOfContentsItem {\n  level: number;\n  text: string;\n  id: string;\n  children: TableOfContentsItem[];\n}\n```\n\n**Properties:**\n- `level` (number): Heading level\n- `text` (string): Heading text\n- `id` (string): Heading ID\n- `children` (TableOfContentsItem[]): Child items\n\n## Plugin Types\n\n\n\n## Processor Types\n\n### ContentProcessor\n\nInterface for content processors.\n\n```typescript\ninterface ContentProcessor {\n  process(content: string): string;\n}\n```\n\n**Methods:**\n- `process(content: string): string`: Process and transform content\n\n### ProcessorOptions\n\nOptions for content processors.\n\n```typescript\ninterface ProcessorOptions {\n  markdown?: boolean;\n  html?: boolean;\n  custom?: boolean;\n}\n```\n\n**Properties:**\n- `markdown` (boolean, optional): Whether to process markdown\n- `html` (boolean, optional): Whether to process HTML\n- `custom` (boolean, optional): Whether to apply custom processing\n\n## Error Types\n\n### BuildError\n\nError thrown during build process.\n\n```typescript\ninterface BuildError extends Error {\n  code: string;\n  path?: string;\n  details?: any;\n}\n```\n\n**Properties:**\n- `code` (string): Error code\n- `path` (string, optional): File path where error occurred\n- `details` (any, optional): Additional error details\n\n### ContentError\n\nError thrown during content processing.\n\n```typescript\ninterface ContentError extends Error {\n  code: string;\n  path: string;\n  content?: string;\n}\n```\n\n**Properties:**\n- `code` (string): Error code\n- `path` (string): Content file path\n- `content` (string, optional): Content that caused error\n\n## Utility Types\n\n### DeepPartial\n\nMakes all properties in T optional recursively.\n\n```typescript\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n```\n\n### RequiredKeys\n\nExtracts keys of T that are required.\n\n```typescript\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n```\n\n### OptionalKeys\n\nExtracts keys of T that are optional.\n\n```typescript\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n```\n\n## Type Guards\n\n### Type Guards for Runtime Validation\n\n```typescript\nfunction isNavigationItem(obj: any): obj is NavigationItem {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    typeof obj.name === 'string' &&\n    typeof obj.type === 'string' &&\n    (obj.type === 'page' || obj.type === 'section') &&\n    typeof obj.label === 'string'\n  );\n}\n\nfunction isNavigationData(obj: any): obj is NavigationData {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    Array.isArray(obj.items) &&\n    obj.items.every(isNavigationItem)\n  );\n}\n\nfunction isContentBundle(obj: any): obj is ContentBundle {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    Object.keys(obj).every(key => typeof obj[key] === 'string')\n  );\n}\n\nfunction isPlugin(obj: any): obj is Plugin {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    typeof obj.name === 'string' &&\n    typeof obj.version === 'string'\n  );\n}\n```\n\n## Zod Schemas\n\n### Validation Schemas\n\n```typescript\nimport { z } from 'zod';\n\nconst NavigationItemSchema = z.object({\n  name: z.string(),\n  type: z.enum(['page', 'section']),\n  label: z.string(),\n  items: z.array(z.lazy(() => NavigationItemSchema)).optional(),\n  collapsed: z.boolean().optional(),\n  url: z.string().url().optional()\n});\n\nconst NavigationDataSchema = z.object({\n  items: z.array(NavigationItemSchema)\n});\n\nconst ContentBundleSchema = z.record(z.string(), z.string());\n\nconst PluginSchema = z.object({\n  name: z.string(),\n  version: z.string(),\n  process: z.function().args(z.string()).returns(z.string()).optional(),\n  transform: z.function().args(z.string()).returns(z.string()).optional(),\n  validate: z.function().args(z.string()).returns(z.boolean()).optional(),\n  beforeBuild: z.function().returns(z.void()).optional(),\n  afterBuild: z.function().args(z.any()).returns(z.void()).optional()\n});\n\nconst BuildOptionsSchema = z.object({\n  appOutput: z.string().optional(),\n  websiteOutput: z.string().optional(),\n  staticOutput: z.string().optional(),\n  includeContent: z.boolean().optional(),\n  processor: z.object({\n    process: z.function().args(z.string()).returns(z.string())\n  }).optional(),\n  plugins: z.array(PluginSchema).optional(),\n  hooks: z.object({\n    beforeBuild: z.function().args(z.string()).returns(z.union([z.void(), z.promise(z.void())])).optional(),\n    afterBuild: z.function().args(z.any()).returns(z.union([z.void(), z.promise(z.void())])).optional(),\n    onError: z.function().args(z.instanceof(Error)).returns(z.void()).optional()\n  }).optional()\n});\n```\n\n## Usage Examples\n\n### Type-Safe Navigation\n\n```typescript\nimport type { NavigationItem, NavigationData } from 'markpage';\n\nfunction validateNavigation(data: unknown): NavigationData {\n  if (!isNavigationData(data)) {\n    throw new Error('Invalid navigation data');\n  }\n  return data;\n}\n\nfunction findPage(items: NavigationItem[], name: string): NavigationItem | null {\n  for (const item of items) {\n    if (item.name === name && item.type === 'page') {\n      return item;\n    }\n    if (item.items) {\n      const found = findPage(item.items, name);\n      if (found) return found;\n    }\n  }\n  return null;\n}\n```\n\n### Type-Safe Content Processing\n\n```typescript\nimport type { ContentProcessor, ContentBundle } from 'markpage';\n\nfunction createProcessor(options: ProcessorOptions): ContentProcessor {\n  return {\n    process(content: string): string {\n      let processed = content;\n      \n      if (options.markdown) {\n        processed = processMarkdown(processed);\n      }\n      \n      if (options.html) {\n        processed = processHtml(processed);\n      }\n      \n      if (options.custom) {\n        processed = processCustom(processed);\n      }\n      \n      return processed;\n    }\n  };\n}\n\nfunction validateContentBundle(bundle: unknown): ContentBundle {\n  if (!isContentBundle(bundle)) {\n    throw new Error('Invalid content bundle');\n  }\n  return bundle;\n}\n```\n\n### Type-Safe Plugin Development\n\n```typescript\nimport type { Plugin, PluginConfig } from 'markpage';\n\nfunction createPlugin(config: PluginConfig): Plugin {\n  return {\n    name: 'my-plugin',\n    version: '1.0.0',\n    process(content: string): string {\n      if (!config.enabled) {\n        return content;\n      }\n      \n      // Apply plugin processing based on config.options\n      return content;\n    }\n  };\n}\n\nfunction validatePlugin(plugin: unknown): Plugin {\n  if (!isPlugin(plugin)) {\n    throw new Error('Invalid plugin');\n  }\n  return plugin;\n}\n```\n\n## Svelte Package Types\n\n### MarkpageOptions\n\nConfiguration class for the Markdown component in `@markpage/svelte`. This class provides a fluent interface for setting up component registration, token overrides, and markdown extensions.\n\n```typescript\nclass MarkpageOptions {\n  addCustomComponent(name: string, component: Component): this;\n  overrideBuiltinToken(name: string, component: Component): this;\n  extendMarkdown(extensions: MarkdownExtensionSet | MarkdownExtensionSet[]): this;\n  useMarkedInstance(instance: Marked): this;\n  useMarkedFactory(factory: () => Marked): this;\n  getComponents(): Map<string, Component>;\n  getExtensionComponents(): Map<string, Component>;\n  getMarked(): Marked;\n  getExtensions(): MarkdownExtensionSet[];\n}\n```\n\n**Public Methods:**\n- `addCustomComponent(name, component)`: Register a custom component for use as a tag in markdown. Components can contain nested markdown content and other components.\n- `overrideBuiltinToken(name, component)`: Override a built-in markdown token with a custom component (e.g., `paragraph`, `heading`, `list`, etc.)\n- `extendMarkdown(extensions)`: Register markdown extensions with their associated components. Extensions can add completely new markdown syntax.\n- `useMarkedInstance(instance)`: Use a specific Marked instance for parsing. Useful for advanced customization.\n- `useMarkedFactory(factory)`: Use a factory function to create Marked instances. Allows for dynamic instance creation.\n\n**Internal Methods:**\n- `getComponents()`: Get the Map of registered custom components\n- `getExtensionComponents()`: Get the Map of extension and override components\n- `getMarked()`: Get the configured Marked instance (creates default with extensions if none set)\n- `getExtensions()`: Get all registered markdown extensions\n\n### MarkdownExtension\n\nRepresents a markdown extension with an associated component.\n\n```typescript\ninterface MarkdownExtension {\n  name: string;\n  level: 'block' | 'inline';\n  component: Component;\n  start(src: string): number | undefined;\n  tokenizer(src: string): any;\n}\n```\n\n**Properties:**\n- `name` (string): Name of the token type\n- `level` ('block' | 'inline'): Whether the extension is block or inline level\n- `component` (Component): Svelte component to render the token\n- `start(src: string): number | undefined`: Function to find the start position of the token\n- `tokenizer(src: string): any`: Function to parse the token from source\n\n### MarkdownExtensionSet\n\nCollection of markdown extensions.\n\n```typescript\ninterface MarkdownExtensionSet {\n  extensions: MarkdownExtension[];\n}\n```\n\n**Properties:**\n- `extensions` (MarkdownExtension[]): Array of markdown extensions\n\n### ComponentName\n\nType for component names in the markdown system.\n\n```typescript\ntype ComponentName = string;\n```\n\n### ComponentNode\n\nRepresents a component node parsed from markdown.\n\n```typescript\ninterface ComponentNode {\n  name: string;\n  props: Record<string, any>;\n  children?: string;\n  position: { start: number; end: number };\n}\n```\n\n**Properties:**\n- `name` (string): Component name\n- `props` (Record<string, any>): Component props\n- `children` (string, optional): Component children content\n- `position` (object): Start and end positions in source\n\n### ComponentOptions\n\nOptions for component registration.\n\n```typescript\ninterface ComponentOptions {\n  defaultProps?: Record<string, any>;\n  validate?: (props: Record<string, any>) => boolean | string;\n}\n```\n\n**Properties:**\n- `defaultProps` (Record<string, any>, optional): Default props for the component\n- `validate` (function, optional): Validation function for component props\n\n### RegisteredComponent\n\nInformation about a registered component.\n\n```typescript\ninterface RegisteredComponent {\n  component: Component;\n  options: ComponentOptions;\n}\n```\n\n**Properties:**\n- `component` (Component): The Svelte component\n- `options` (ComponentOptions): Component configuration options\n\n### ParsedContent\n\nResult of parsing content.\n\n```typescript\ninterface ParsedContent {\n  type: 'text' | 'component';\n  content: string | ComponentNode;\n}\n```\n\n**Properties:**\n- `type` ('text' | 'component'): Type of parsed content\n- `content` (string | ComponentNode): The parsed content\n\n### MarkpageSvelteOptions\n\nOptions for the MarkpageSvelte instance.\n\n```typescript\ninterface MarkpageSvelteOptions {\n  enableComponents?: boolean;\n  strictMode?: boolean;\n}\n```\n\n**Properties:**\n- `enableComponents` (boolean, optional): Whether to enable component parsing\n- `strictMode` (boolean, optional): Whether to use strict parsing mode\n\n### RenderContext\n\nContext for component rendering.\n\n```typescript\ninterface RenderContext {\n  path: string;\n  navigation: NavigationItem[];\n  content: Record<string, string>;\n}\n```\n\n**Properties:**\n- `path` (string): Current content path\n- `navigation` (NavigationItem[]): Navigation structure\n- `content` (Record<string, string>): Available content\n\n## Related\n\n- [Builder API](./builder.md) - Content building and generation\n- [Renderer API](./renderer.md) - Content rendering and navigation\n",
  "how-to-contribute.md": "# How to Contribute\n\nThis document is for contributors who want to work on the Markpage project.\n\n## Project Structure\n\nThis is a monorepo with the following packages:\n\n- **`packages/markpage`** - The main package that gets published to npm\n- **`packages/markpage-svelte`** - Svelte integration package (components in markdown)\n- **`packages/tests`** - Comprehensive test suite for the package\n- **`packages/website`** - This documentation website\n\n## Prerequisites\n\n- Node.js 18+\n- npm\n\n## Setup\n\n```bash\n# Install dependencies for all packages\nnpm ci\n\n# Build all packages\nnpm run build:pkgs\n\n# Run tests\nnpm test\n```\n\n## Package Scripts\n\n### Root Scripts\n- `npm run build` - Build all packages and the website\n- `npm run build:pkgs` - Build markpage and markpage-svelte packages\n- `npm test` - Build packages and run all tests\n- `npm run test:watch` - Run tests in watch mode\n- `npm run test:coverage` - Run tests with coverage report\n- `npm run dev:website` - Start the documentation website\n- `npm run build:website` - Build the documentation website\n\n### Individual Package Scripts\n- `npm run dev --workspace=markpage` - Watch mode for the main package\n- `npm run build --workspace=@markpage/svelte` - Build the Svelte package\n- `npm run check --workspace=@markpage/website` - Run Svelte type checks\n\n## Development Workflow\n\n### Building\n\nThe main package uses [tsup](https://github.com/egoist/tsup) for building:\n\n```bash\n# Build all packages\nnpm run build:pkgs\n\n# Or build individual packages\nnpm run build --workspace=markpage\nnpm run build --workspace=@markpage/svelte\n```\n\n### Testing\n\nTests are run using Vitest and must be kept green:\n\n```bash\n# Run all tests (builds packages first)\nnpm test\n\n# Watch mode for development\nnpm run test:watch\n\n# Coverage report\nnpm run test:coverage\n```\n\n### Website Development\n\nThe documentation website is built with SvelteKit and auto-builds content from `./docs`:\n\n```bash\n# Start dev server (auto-builds content)\nnpm run dev:website\n\n# Build for production\nnpm run build:website\n\n# Preview production build\nnpm --workspace=@markpage/website run preview\n```\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Add tests for new functionality\n5. Ensure all tests pass\n6. Submit a pull request\n\n## Code Style\n\n- TypeScript for all source code\n- Svelte 5 with runes mode for components\n- Comprehensive test coverage (keep tests green)\n- Follow existing patterns and conventions\n\n## Package Publishing\n\nPackages are published from their respective directories:\n\n```bash\n# Main package\ncd packages/markpage\nnpm publish\n\n# Svelte integration\ncd packages/markpage-svelte\nnpm publish\n```\n\n## License\n\nMIT License - see [LICENSE](https://github.com/mitkury/markpage/blob/main/LICENSE) file for details.\n"
}